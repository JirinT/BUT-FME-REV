Disassembly Listing for MicroProject
Generated From:
C:/Users/Misak/Desktop/MicroProject.X/dist/default/production/MicroProject.X.production.elf
7.3.2020 20:22:42

---  C:/Users/Misak/Desktop/MicroProject.X/main.c  ------------------------------------------------------
1:             // REV MicroProject
2:             #pragma config FOSC = HSMP      // Oscillator Selection bits (HS oscillator (medium power 4-16 MHz))
3:             #pragma config PLLCFG = ON      // 4X PLL Enable (Oscillator multiplied by 4)
4:             #pragma config WDTEN = OFF      // Watchdog Timer Enable bits (Watch dog timer is always disabled. SWDTEN has no effect.)
5:             
6:             #include <xc.h>                 // knihovna microchip
7:             #include <stdio.h>              // std pro sprintf
8:             #include <stdint.h>             // unifikovane datove typy
9:             
10:            #include "bsl.h"                // knihovna pro REVkit
11:            #include "lcd.h"                // knihovna pro LCD
12:            
13:            // definice 
14:            #define DELAY (0xffff - 10000)   // delay 10ms
15:            #define START BTN1
16:            #define STOP BTN2
17:            #define RESET BTN3
18:            
19:            
20:            typedef struct{
21:                char state;
22:            }button;
23:            
24:            volatile uint8_t timer_flag=0;
25:            
26:            void __interrupt() ISR(void){
0008  825F     BSF btemp, 1, ACCESS
27:            
28:                if (TMR1IE && TMR1IF){
000A  B09D     BTFSC PIE1, 0, ACCESS
000C  A09E     BTFSS PIR1, 0, ACCESS
000E  D008     BRA 0x20
29:                    
30:                    
31:                    timer_flag = 1;
0010  0E01     MOVLW 0x1
0012  0100     MOVLB 0x0
0014  6F66     MOVWF timer_flag, BANKED
32:                    TMR1 = DELAY;
0016  0ED8     MOVLW 0xD8
0018  6ECF     MOVWF TMR1H, ACCESS
001A  0EEF     MOVLW 0xEF
001C  6ECE     MOVWF TMR1, ACCESS
33:                    TMR1IF = 0;
001E  909E     BCF PIR1, 0, ACCESS
34:                }
35:            
36:            }
0020  925F     BCF btemp, 1, ACCESS
0022  0011     RETFIE 1
37:            
38:            int main(void) {
39:                
40:                init_gpio();                // provedu nastaveni SFR pro GPIO
1926  EC6B     CALL 0x1CD6, 0
1928  F00E     NOP
41:                LCD_Init();                 // inicializace LCD
192A  EC31     CALL 0x1862, 0
192C  F00C     NOP
42:                init_tmr1();                // provedu nastaveni SFR pro TMR1
192E  ECBD     CALL 0x1D7A, 0
1930  F00E     NOP
43:                
44:                PEIE = 1;                   // preruseni periferie
1932  8CF2     BSF INTCON, 6, ACCESS
45:                GIE = 1;                    // preruseni globalne
1934  8EF2     BSF INTCON, 7, ACCESS
46:                TMR1 = DELAY;               // nastavim registr timeru1
1936  0ED8     MOVLW 0xD8
1938  6ECF     MOVWF TMR1H, ACCESS
193A  0EEF     MOVLW 0xEF
193C  6ECE     MOVWF TMR1, ACCESS
47:                T1CONbits.TMR1ON = 1;       // zapnu timer
193E  80CD     BSF T1CON, 0, ACCESS
48:                
49:                char text[17];
50:                uint8_t hos=0,
1940  0E00     MOVLW 0x0
1942  0100     MOVLB 0x0
1944  6FA1     MOVWF hos, BANKED
51:                        minutes=0,
1946  0E00     MOVLW 0x0
1948  6FA2     MOVWF minutes, BANKED
52:                        seconds=0;
194A  0E00     MOVLW 0x0
194C  6FA3     MOVWF seconds, BANKED
53:                char leds = 0b111111;
194E  0E3F     MOVLW 0x3F
1950  6FA0     MOVWF leds, BANKED
54:                
55:                LCD_ShowString(1, "Timer:        ");
1952  0E17     MOVLW 0x17
1954  6E02     MOVWF textData, ACCESS
1956  5002     MOVF textData, W, ACCESS
1958  A4D8     BTFSS STATUS, 2, ACCESS
195A  0E10     MOVLW 0x10
195C  6E03     MOVWF fp, ACCESS
195E  0E01     MOVLW 0x1
1960  EC66     CALL 0x1ACC, 0
1962  F00D     NOP
56:                
57:                while(1){
58:                    if (timer_flag){
1964  0100     MOVLB 0x0
1966  5166     MOVF timer_flag, W, BANKED
1968  B4D8     BTFSC STATUS, 2, ACCESS
196A  D7FC     BRA 0x1964
59:                        hos++;
196C  2BA1     INCF hos, F, BANKED
60:                        if (hos >=100){
196E  0E63     MOVLW 0x63
1970  65A1     CPFSGT hos, BANKED
1972  D014     BRA 0x199C
61:                            seconds++;
1974  2BA3     INCF seconds, F, BANKED
62:                            hos = 0;
1976  0E00     MOVLW 0x0
1978  6FA1     MOVWF hos, BANKED
63:                            leds ^= 0b111111;
197A  0E3F     MOVLW 0x3F
197C  1BA0     XORWF leds, F, BANKED
64:                            drive_leds(leds);
197E  51A0     MOVF leds, W, BANKED
1980  ECC7     CALL 0x1B8E, 0
1982  F00D     NOP
65:                            if (seconds >=60){
1984  0E3B     MOVLW 0x3B
1986  0100     MOVLB 0x0
1988  65A3     CPFSGT seconds, BANKED
198A  D008     BRA 0x199C
66:                                minutes++;
198C  2BA2     INCF minutes, F, BANKED
67:                                seconds = 0;
198E  0E00     MOVLW 0x0
1990  6FA3     MOVWF seconds, BANKED
68:                                if (minutes >= 99)
1992  0E62     MOVLW 0x62
1994  65A2     CPFSGT minutes, BANKED
1996  D002     BRA 0x199C
69:                                    minutes = 0;
1998  0E00     MOVLW 0x0
199A  6FA2     MOVWF minutes, BANKED
70:                            }
71:                        }
72:                        
73:                    sprintf(text, "%02d:%02d.%02d       ", minutes, seconds, hos);
199C  0E8F     MOVLW 0x8F
199E  6E55     MOVWF s, ACCESS
19A0  0E01     MOVLW 0x1
19A2  6E56     MOVWF fmt, ACCESS
19A4  C0A2     MOVFF minutes, 0x57
19A6  F057     NOP
19A8  6A58     CLRF 0x58, ACCESS
19AA  C0A3     MOVFF seconds, 0x59
19AC  F059     NOP
19AE  6A5A     CLRF 0x5A, ACCESS
19B0  C0A1     MOVFF hos, 0x5B
19B2  F05B     NOP
19B4  6A5C     CLRF 0x5C, ACCESS
19B6  EC07     CALL 0x1C0E, 0
19B8  F00E     NOP
74:                    LCD_ShowString(2, text);
19BA  0E8F     MOVLW 0x8F
19BC  6E02     MOVWF textData, ACCESS
19BE  6A03     CLRF fp, ACCESS
19C0  0E02     MOVLW 0x2
19C2  EC66     CALL 0x1ACC, 0
19C4  F00D     NOP
75:                    timer_flag = 0;
19C6  0E00     MOVLW 0x0
19C8  0100     MOVLB 0x0
19CA  6F66     MOVWF timer_flag, BANKED
19CC  D7CB     BRA 0x1964
76:                    }
77:            
78:                }
79:                return 0;                     
80:            }
---  C:/Users/Misak/Desktop/MicroProject.X/lcd.c  -------------------------------------------------------
1:             #include <xc.h>
2:             #include <stdio.h>
3:             #include "lcd.h"
4:             #define _XTAL_FREQ 32E6
5:             
6:             void LCD_Init(void){
7:                 
8:                 ANSELDbits.ANSD0 = 0;
1862  913B     BCF 0x3B, 0, BANKED
9:                 ANSELDbits.ANSD1 = 0;
1864  933B     BCF 0x3B, 1, BANKED
10:                
11:                TRISDbits.TRISD0 = 1;   // pin as input
1866  8095     BSF TRISD, 0, ACCESS
12:                TRISDbits.TRISD1 = 1;   // pin as input
1868  8295     BSF TRISD, 1, ACCESS
13:                TRISAbits.TRISA0 = 0;   // pin as input
186A  9092     BCF TRISA, 0, ACCESS
14:                LATAbits.LATA0 = 1;
186C  8089     BSF LATA, 0, ACCESS
15:                
16:                
17:                SSP2CON1bits.SSPM = 0b1000; // I2C Master mode
186E  506C     MOVF SSP2CON1, W, ACCESS
1870  0BF0     ANDLW 0xF0
1872  0908     IORLW 0x8
1874  6E6C     MOVWF SSP2CON1, ACCESS
18:                SSP2ADD = 19; 
1876  0E13     MOVLW 0x13
1878  6E6E     MOVWF SSP2ADD, ACCESS
19:                SSP2CON1bits.SSPEN = 1;     // enable
187A  8A6C     BSF SSP2CON1, 5, ACCESS
20:                
21:                __delay_ms(5);
187C  0E34     MOVLW 0x34
187E  6E02     MOVWF textData, ACCESS
1880  0EF2     MOVLW 0xF2
1882  2EE8     DECFSZ WREG, F, ACCESS
1884  D7FE     BRA 0x1882
1886  2E02     DECFSZ textData, F, ACCESS
1888  D7FC     BRA 0x1882
22:                
23:                SSP2CON2bits.SEN = 1;
188A  806B     BSF SSP2CON2, 0, ACCESS
24:                while (SSP2CON2bits.SEN);
188C  B06B     BTFSC SSP2CON2, 0, ACCESS
188E  D7FE     BRA 0x188C
25:                SSP2IF = 0;
1890  9EA4     BCF PIR3, 7, ACCESS
26:                
27:                // LCD addr:  0111110 (0x3E)
28:                // LCD write: 01111100 (0x7C)
29:                
30:                LCD_Send(0x7C); // device addr write
1892  0E7C     MOVLW 0x7C
1894  ECB4     CALL 0x1D68, 0
1896  F00E     NOP
31:                LCD_Send(0x80); // Control byte
1898  0E80     MOVLW 0x80
189A  ECB4     CALL 0x1D68, 0
189C  F00E     NOP
32:                LCD_Send(0x38); // function set
189E  0E38     MOVLW 0x38
18A0  ECB4     CALL 0x1D68, 0
18A2  F00E     NOP
33:                LCD_Send(0x80);
18A4  0E80     MOVLW 0x80
18A6  ECB4     CALL 0x1D68, 0
18A8  F00E     NOP
34:                LCD_Send(0x39); // function set
18AA  0E39     MOVLW 0x39
18AC  ECB4     CALL 0x1D68, 0
18AE  F00E     NOP
35:                LCD_Send(0x80);
18B0  0E80     MOVLW 0x80
18B2  ECB4     CALL 0x1D68, 0
18B4  F00E     NOP
36:                LCD_Send(0x17); // internal OSC freq
18B6  0E17     MOVLW 0x17
18B8  ECB4     CALL 0x1D68, 0
18BA  F00E     NOP
37:                LCD_Send(0x80);
18BC  0E80     MOVLW 0x80
18BE  ECB4     CALL 0x1D68, 0
18C0  F00E     NOP
38:                LCD_Send(0x7A); // contrast set
18C2  0E7A     MOVLW 0x7A
18C4  ECB4     CALL 0x1D68, 0
18C6  F00E     NOP
39:                LCD_Send(0x80);
18C8  0E80     MOVLW 0x80
18CA  ECB4     CALL 0x1D68, 0
18CC  F00E     NOP
40:                LCD_Send(0x5E); // Power/ICON control/Contrast set
18CE  0E5E     MOVLW 0x5E
18D0  ECB4     CALL 0x1D68, 0
18D2  F00E     NOP
41:                LCD_Send(0x80);
18D4  0E80     MOVLW 0x80
18D6  ECB4     CALL 0x1D68, 0
18D8  F00E     NOP
42:                LCD_Send(0x6B); // Follower conrol
18DA  0E6B     MOVLW 0x6B
18DC  ECB4     CALL 0x1D68, 0
18DE  F00E     NOP
43:                LCD_Send(0x80);
18E0  0E80     MOVLW 0x80
18E2  ECB4     CALL 0x1D68, 0
18E4  F00E     NOP
44:                LCD_Send(0x0C); // Display ON/OFF
18E6  0E0C     MOVLW 0xC
18E8  ECB4     CALL 0x1D68, 0
18EA  F00E     NOP
45:                LCD_Send(0x80);
18EC  0E80     MOVLW 0x80
18EE  ECB4     CALL 0x1D68, 0
18F0  F00E     NOP
46:                LCD_Send(0x01); // Clear display
18F2  0E01     MOVLW 0x1
18F4  ECB4     CALL 0x1D68, 0
18F6  F00E     NOP
47:                LCD_Send(0x80);
18F8  0E80     MOVLW 0x80
18FA  ECB4     CALL 0x1D68, 0
18FC  F00E     NOP
48:                LCD_Send(0x06);
18FE  0E06     MOVLW 0x6
1900  ECB4     CALL 0x1D68, 0
1902  F00E     NOP
49:                LCD_Send(0x80);
1904  0E80     MOVLW 0x80
1906  ECB4     CALL 0x1D68, 0
1908  F00E     NOP
50:                LCD_Send(0x02);
190A  0E02     MOVLW 0x2
190C  ECB4     CALL 0x1D68, 0
190E  F00E     NOP
51:              
52:                SSP2CON2bits.PEN = 1;
1910  846B     BSF SSP2CON2, 2, ACCESS
53:                while (SSP2CON2bits.PEN);
1912  B46B     BTFSC SSP2CON2, 2, ACCESS
1914  D7FE     BRA 0x1912
54:                
55:                __delay_ms(5);
1916  0E34     MOVLW 0x34
1918  6E02     MOVWF textData, ACCESS
191A  0EF2     MOVLW 0xF2
191C  2EE8     DECFSZ WREG, F, ACCESS
191E  D7FE     BRA 0x191C
1920  2E02     DECFSZ textData, F, ACCESS
1922  D7FC     BRA 0x191C
56:            }
1924  0012     RETURN 0
57:            
58:            void LCD_ShowString(char lineNum, char textData[])
1ACC  6E06     MOVWF lineNum, ACCESS
59:            {
60:                unsigned char i;
61:                i = 0;
62:                
63:                SSP2CON2bits.SEN = 1;
1ACE  806B     BSF SSP2CON2, 0, ACCESS
64:                while (SSP2CON2bits.SEN);
1AD0  B06B     BTFSC SSP2CON2, 0, ACCESS
1AD2  D7FE     BRA 0x1AD0
65:                SSP2IF = 0;
1AD4  9EA4     BCF PIR3, 7, ACCESS
66:                
67:                LCD_Send(0x7c);
1AD6  0E7C     MOVLW 0x7C
1AD8  ECB4     CALL 0x1D68, 0
1ADA  F00E     NOP
68:            
69:                LCD_Send(0x80);
1ADC  0E80     MOVLW 0x80
1ADE  ECB4     CALL 0x1D68, 0
1AE0  F00E     NOP
70:                
71:                if(lineNum == 1){
1AE2  0406     DECF lineNum, W, ACCESS
1AE4  A4D8     BTFSS STATUS, 2, ACCESS
1AE6  D004     BRA 0x1AF0
72:                    LCD_Send(0x80);
1AE8  0E80     MOVLW 0x80
1AEA  ECB4     CALL 0x1D68, 0
1AEC  F00E     NOP
73:                }
1AEE  D007     BRA 0x1AFE
74:                else if (lineNum == 2){
1AF0  0E02     MOVLW 0x2
1AF2  1806     XORWF lineNum, W, ACCESS
1AF4  A4D8     BTFSS STATUS, 2, ACCESS
1AF6  D003     BRA 0x1AFE
75:                    LCD_Send(0xC0);
1AF8  0EC0     MOVLW 0xC0
1AFA  ECB4     CALL 0x1D68, 0
1AFC  F00E     NOP
76:                }
77:                
78:                LCD_Send(0x40);
1AFE  0E40     MOVLW 0x40
1B00  ECB4     CALL 0x1D68, 0
1B02  F00E     NOP
79:                
80:                for (i = 0; i<16; i++){
1B04  0E00     MOVLW 0x0
1B06  6E07     MOVWF i, ACCESS
81:                    LCD_Send(textData[i]);
1B08  5007     MOVF i, W, ACCESS
1B0A  2402     ADDWF textData, W, ACCESS
1B0C  6E04     MOVWF 0x4, ACCESS
1B0E  0E00     MOVLW 0x0
1B10  2003     ADDWFC fp, W, ACCESS
1B12  6E05     MOVWF product, ACCESS
1B14  C004     MOVFF 0x4, TBLPTR
1B16  FFF6     NOP
1B18  C005     MOVFF product, TBLPTRH
1B1A  FFF7     NOP
1B1C  0E00     MOVLW 0x0
1B1E  6EF8     MOVWF TBLPTRU, ACCESS
1B20  0E0F     MOVLW 0xF
1B22  64F7     CPFSGT TBLPTRH, ACCESS
1B24  D003     BRA 0x1B2C
1B26  0008     TBLRD*
1B28  50F5     MOVF TABLAT, W, ACCESS
1B2A  D005     BRA 0x1B36
1B2C  CFF6     MOVFF TBLPTR, FSR1
1B2E  FFE1     NOP
1B30  CFF7     MOVFF TBLPTRH, FSR1H
1B32  FFE2     NOP
1B34  50E7     MOVF INDF1, W, ACCESS
1B36  ECB4     CALL 0x1D68, 0
1B38  F00E     NOP
82:                }
1B3A  2A07     INCF i, F, ACCESS
1B3C  0E0F     MOVLW 0xF
1B3E  6407     CPFSGT i, ACCESS
1B40  D7E3     BRA 0x1B08
83:                
84:                SSP2CON2bits.PEN = 1;
1B42  846B     BSF SSP2CON2, 2, ACCESS
85:                while (SSP2CON2bits.PEN);
1B44  A46B     BTFSS SSP2CON2, 2, ACCESS
1B46  0012     RETURN 0
1B48  D7FD     BRA 0x1B44
86:            }
87:            
88:            static void LCD_Send(unsigned char data){
1D68  6E01     MOVWF __pcstackCOMRAM, ACCESS
89:                
90:                SSP2BUF = data;
1D6A  C001     MOVFF __pcstackCOMRAM, SSP2BUF
1D6C  FF6F     NOP
91:                while(SSP2STATbits.BF);
1D6E  B06D     BTFSC SSP2STAT, 0, ACCESS
1D70  D7FE     BRA 0x1D6E
92:                while(!SSP2IF);
1D72  AEA4     BTFSS PIR3, 7, ACCESS
1D74  D7FE     BRA 0x1D72
93:                SSP2IF = 0;
1D76  9EA4     BCF PIR3, 7, ACCESS
94:                
95:            }
0008  825F     BSF btemp, 1, ACCESS
1D78  0012     RETURN 0
96:            
97:            void LCD_Clear(void){
98:                SSP2CON2bits.SEN = 1;
99:                while (SSP2CON2bits.SEN);
100:               SSP2IF = 0;
101:               
102:               LCD_Send(0x7C); // device addr write
103:               LCD_Send(0x80); // Control byte
104:               LCD_Send(0x01); // Clear display
105:               
106:               SSP2CON2bits.PEN = 1;
107:               while (SSP2CON2bits.PEN);      
108:           }
109:           
110:           void LCD_Reset(void){
111:               LATAbits.LATA0 = 0;
112:               __delay_us(100);
113:               LATAbits.LATA0 = 1;
114:           }
---  C:/Users/Misak/Desktop/MicroProject.X/bsl.c  -------------------------------------------------------
1:             #include "bsl.h"
2:             
3:             void init_gpio(void){
4:             
5:                 // vypnu analogove funkce pro input
6:                 ANSELA = 0x00;
1CD6  0E00     MOVLW 0x0
1CD8  010F     MOVLB 0xF
1CDA  6F38     MOVWF 0x38, BANKED
7:                 ANSELC = 0x00;
1CDC  0E00     MOVLW 0x0
1CDE  6F3A     MOVWF 0x3A, BANKED
8:                 
9:                 // ledky
10:                TRISDbits.TRISD2 = 0;
1CE0  9495     BCF TRISD, 2, ACCESS
11:                TRISDbits.TRISD3 = 0;
1CE2  9695     BCF TRISD, 3, ACCESS
12:                TRISCbits.TRISC4 = 0;
1CE4  9894     BCF TRISC, 4, ACCESS
13:                TRISDbits.TRISD4 = 0;
1CE6  9895     BCF TRISD, 4, ACCESS
14:                TRISDbits.TRISD5 = 0;
1CE8  9A95     BCF TRISD, 5, ACCESS
15:                TRISDbits.TRISD6 = 0;
1CEA  9C95     BCF TRISD, 6, ACCESS
16:                
17:                // knofliky
18:                TRISAbits.TRISA4 = 1;
1CEC  8892     BSF TRISA, 4, ACCESS
19:                TRISAbits.TRISA3 = 1;
1CEE  8692     BSF TRISA, 3, ACCESS
20:                TRISAbits.TRISA2 = 1;
1CF0  8492     BSF TRISA, 2, ACCESS
21:                TRISCbits.TRISC0 = 1;
1CF2  8094     BSF TRISC, 0, ACCESS
22:                
23:                // zhasnu ledky
24:                LED1 = 1;
1CF4  848C     BSF LATD, 2, ACCESS
25:                LED2 = 1;
1CF6  868C     BSF LATD, 3, ACCESS
26:                LED3 = 1;
1CF8  888B     BSF LATC, 4, ACCESS
27:                LED4 = 1;
1CFA  888C     BSF LATD, 4, ACCESS
28:                LED5 = 1;
1CFC  8A8C     BSF LATD, 5, ACCESS
29:                LED6 = 1;
1CFE  8C8C     BSF LATD, 6, ACCESS
30:                
31:            }
1D00  0012     RETURN 0
32:            
33:            void init_tmr1(void){
34:            
35:                T1CONbits.TMR1CS = 0b00;        // zdroj casovace 1
1D7A  0E3F     MOVLW 0x3F
1D7C  16CD     ANDWF T1CON, F, ACCESS
36:                T1CONbits.T1CKPS = 0b11;        // nastaveni delicky                                             
1D7E  0E30     MOVLW 0x30
1D80  12CD     IORWF T1CON, F, ACCESS
37:                TMR1IE = 1;                     // povoleni preruseni pro TMR1
1D82  809D     BSF PIE1, 0, ACCESS
38:                TMR1IF = 0;                     // smazani priznaku (pro jistotu)
1D84  909E     BCF PIR1, 0, ACCESS
39:            }
1D86  0012     RETURN 0
40:            
41:            void drive_leds(char in){
1B8E  6E01     MOVWF __pcstackCOMRAM, ACCESS
42:                
43:                in = ~in;
1B90  1E01     COMF __pcstackCOMRAM, F, ACCESS
44:                LATD2 = in & 1;             //LED0
1B92  A001     BTFSS __pcstackCOMRAM, 0, ACCESS
1B94  D002     BRA 0x1B9A
1B96  848C     BSF LATD, 2, ACCESS
1B98  D001     BRA 0x1B9C
1B9A  948C     BCF LATD, 2, ACCESS
45:                LATD3 = in & 2 ? 1 : 0;     //LED1
1B9C  A201     BTFSS __pcstackCOMRAM, 1, ACCESS
1B9E  D002     BRA 0x1BA4
1BA0  868C     BSF LATD, 3, ACCESS
1BA2  D001     BRA 0x1BA6
1BA4  968C     BCF LATD, 3, ACCESS
46:                LATC4 = in & 4 ? 1 : 0;     //LED2
1BA6  A401     BTFSS __pcstackCOMRAM, 2, ACCESS
1BA8  D002     BRA 0x1BAE
1BAA  888B     BSF LATC, 4, ACCESS
1BAC  D001     BRA 0x1BB0
1BAE  988B     BCF LATC, 4, ACCESS
47:                LATD4 = in & 8 ? 1 : 0;     //LED3
1BB0  A601     BTFSS __pcstackCOMRAM, 3, ACCESS
1BB2  D002     BRA 0x1BB8
1BB4  888C     BSF LATD, 4, ACCESS
1BB6  D001     BRA 0x1BBA
1BB8  988C     BCF LATD, 4, ACCESS
48:                LATD5 = in & 16 ? 1 : 0;    //LED4
1BBA  A801     BTFSS __pcstackCOMRAM, 4, ACCESS
1BBC  D002     BRA 0x1BC2
1BBE  8A8C     BSF LATD, 5, ACCESS
1BC0  D001     BRA 0x1BC4
1BC2  9A8C     BCF LATD, 5, ACCESS
49:                LATD6 = in & 32 ? 1 : 0;    //LED5
1BC4  AA01     BTFSS __pcstackCOMRAM, 5, ACCESS
1BC6  D002     BRA 0x1BCC
1BC8  8C8C     BSF LATD, 6, ACCESS
1BCA  0012     RETURN 0
1BCC  9C8C     BCF LATD, 6, ACCESS
50:                
51:            }
1BCE  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/strlen.c  ------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             #ifndef __XC8__
6:             #define ALIGN (sizeof(size_t))
7:             #define ONES ((size_t)-1/UCHAR_MAX)
8:             #define HIGHS (ONES * (UCHAR_MAX/2+1))
9:             #define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)
10:            #endif
11:            
12:            size_t strlen(const char *s)
13:            {
14:            	const char *a = s;
1D28  C001     MOVFF __pcstackCOMRAM, fp
1D2A  F003     NOP
15:            #ifdef __XC8__
16:            	while(*s) {
1D2C  D001     BRA 0x1D30
1D30  5001     MOVF __pcstackCOMRAM, W, ACCESS
1D32  6ED9     MOVWF FSR2, ACCESS
1D34  6ADA     CLRF FSR2H, ACCESS
1D36  50DF     MOVF INDF2, W, ACCESS
1D38  A4D8     BTFSS STATUS, 2, ACCESS
1D3A  D7F9     BRA 0x1D2E
17:            		s++;
1D2E  2A01     INCF __pcstackCOMRAM, F, ACCESS
18:            	}
19:            #else
20:            	const size_t *w;
21:            	for (; (uintptr_t)s % ALIGN; s++) if (!*s) return s-a;
22:            	for (w = (const void *)s; !HASZERO(*w); w++);
23:            	for (s = (const void *)w; *s; s++);
24:            #endif
25:            	return s-a;
1D3C  5003     MOVF fp, W, ACCESS
1D3E  5C01     SUBWF __pcstackCOMRAM, W, ACCESS
1D40  6E01     MOVWF __pcstackCOMRAM, ACCESS
1D42  6A02     CLRF textData, ACCESS
1D44  BE01     BTFSC __pcstackCOMRAM, 7, ACCESS
1D46  0602     DECF textData, F, ACCESS
26:            }
1D48  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/putch.c  -------------------------
1:             /*
2:              * Function: putch
3:              * Weak implementation.  User implementation may be required
4:              */
5:             
6:             void 
7:             putch(char c)
8:             {
9:             }
1D88  0012     RETURN 0
10:            
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/nf_sprintf.c  --------------------
1:             #include <stdarg.h>
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             /* "No file system" sprintf */
8:             
9:             int sprintf(char *restrict s, const char *restrict fmt, ...)
10:            {
11:            	int ret;
12:            	va_list ap;
13:            	FILE f;
14:            
15:            	va_start(ap, fmt);
1C0E  0E57     MOVLW 0x57
1C10  6F89     MOVWF ap, BANKED
16:            	f.buffer = s;
1C12  C055     MOVFF s, f
1C14  F08A     NOP
17:            	f.count = 0;
1C16  0E00     MOVLW 0x0
1C18  6F8C     MOVWF 0x8C, BANKED
1C1A  0E00     MOVLW 0x0
1C1C  6F8B     MOVWF 0x8B, BANKED
18:            	f.limit = 0;
1C1E  0E00     MOVLW 0x0
1C20  6F8E     MOVWF 0x8E, BANKED
1C22  0E00     MOVLW 0x0
1C24  6F8D     MOVWF 0x8D, BANKED
19:            	ret = vfprintf(&f, fmt, ap);
1C26  0E8A     MOVLW 0x8A
1C28  6E51     MOVWF fp, ACCESS
1C2A  C056     MOVFF fmt, fmt
1C2C  F052     NOP
1C2E  0E89     MOVLW 0x89
1C30  6E53     MOVWF ap, ACCESS
1C32  ECA5     CALL 0x1B4A, 0
1C34  F00D     NOP
20:            	s[f.count] = '\0';
1C36  5055     MOVF s, W, ACCESS
1C38  258B     ADDWF 0x8B, W, BANKED
1C3A  6ED9     MOVWF FSR2, ACCESS
1C3C  6ADA     CLRF FSR2H, ACCESS
1C3E  0E00     MOVLW 0x0
1C40  6EDF     MOVWF INDF2, ACCESS
21:            	va_end(ap);
22:            	return ret;
23:            }
1C42  0012     RETURN 0
24:            
25:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/nf_fputs.c  ----------------------
1:             /* "No file system" fputs */
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             
8:             int fputs(const char *s, FILE *fp)
9:             {
10:                char c;
11:                int i;
12:            
13:                i = 0;
1C76  0E00     MOVLW 0x0
1C78  6E0D     MOVWF 0xD, ACCESS
1C7A  0E00     MOVLW 0x0
1C7C  6E0C     MOVWF i, ACCESS
14:                while ((c = *(s + i))) {
1C7E  D009     BRA 0x1C92
1C92  5009     MOVF divisor, W, ACCESS
15:            	fputc(c,fp);
1C80  C00B     MOVFF c, __pcstackCOMRAM
1C82  F001     NOP
1C84  6A02     CLRF textData, ACCESS
1C86  C00A     MOVFF fp, fp
1C88  F003     NOP
1C8A  ECE7     CALL 0x19CE, 0
1C8C  F00C     NOP
16:                    ++i;
1C8E  4A0C     INFSNZ i, F, ACCESS
1C90  2A0D     INCF 0xD, F, ACCESS
1C92  5009     MOVF divisor, W, ACCESS
1C94  240C     ADDWF i, W, ACCESS
1C96  6ED9     MOVWF FSR2, ACCESS
1C98  6ADA     CLRF FSR2H, ACCESS
1C9A  50DF     MOVF INDF2, W, ACCESS
1C9C  6E0B     MOVWF c, ACCESS
1C9E  500B     MOVF c, W, ACCESS
1CA0  B4D8     BTFSC STATUS, 2, ACCESS
1CA2  0012     RETURN 0
1CA4  D7ED     BRA 0x1C80
17:                }
18:                return i;
19:            }
20:            
21:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/nf_fputc.c  ----------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
19CE  5003     MOVF fp, W, ACCESS
19D0  B4D8     BTFSC STATUS, 2, ACCESS
19D2  D003     BRA 0x19DA
19D4  5003     MOVF fp, W, ACCESS
19D6  A4D8     BTFSS STATUS, 2, ACCESS
19D8  D004     BRA 0x19E2
13:                    putch(c);
19DA  5001     MOVF __pcstackCOMRAM, W, ACCESS
19DC  ECC4     CALL 0x1D88, 0
19DE  F00E     NOP
14:                } else {
19E0  0012     RETURN 0
15:            	if((fp->limit == 0) || (fp->count < fp->limit)) {
19E2  5003     MOVF fp, W, ACCESS
19E4  6ED9     MOVWF FSR2, ACCESS
19E6  6ADA     CLRF FSR2H, ACCESS
19E8  0E03     MOVLW 0x3
19EA  26D9     ADDWF FSR2, F, ACCESS
19EC  50DE     MOVF POSTINC2, W, ACCESS
19EE  10DE     IORWF POSTINC2, W, ACCESS
19F0  B4D8     BTFSC STATUS, 2, ACCESS
19F2  D014     BRA 0x1A1C
19F4  5003     MOVF fp, W, ACCESS
19F6  6ED9     MOVWF FSR2, ACCESS
19F8  6ADA     CLRF FSR2H, ACCESS
19FA  0E03     MOVLW 0x3
19FC  26D9     ADDWF FSR2, F, ACCESS
19FE  5003     MOVF fp, W, ACCESS
1A00  6EE1     MOVWF FSR1, ACCESS
1A02  6AE2     CLRF FSR1H, ACCESS
1A04  0E01     MOVLW 0x1
1A06  26E1     ADDWF FSR1, F, ACCESS
1A08  50DE     MOVF POSTINC2, W, ACCESS
1A0A  5CE6     SUBWF POSTINC1, W, ACCESS
1A0C  50E6     MOVF POSTINC1, W, ACCESS
1A0E  0A80     XORLW 0x80
1A10  6E08     MOVWF s, ACCESS
1A12  50DE     MOVF POSTINC2, W, ACCESS
1A14  0A80     XORLW 0x80
1A16  5808     SUBWFB s, W, ACCESS
1A18  B0D8     BTFSC STATUS, 0, ACCESS
1A1A  0012     RETURN 0
16:            	        fp->buffer[fp->count] = (char)c;
1A1C  5003     MOVF fp, W, ACCESS
1A1E  6ED9     MOVWF FSR2, ACCESS
1A20  6ADA     CLRF FSR2H, ACCESS
1A22  0E01     MOVLW 0x1
1A24  26D9     ADDWF FSR2, F, ACCESS
1A26  50DF     MOVF INDF2, W, ACCESS
1A28  6E04     MOVWF 0x4, ACCESS
1A2A  5003     MOVF fp, W, ACCESS
1A2C  6ED9     MOVWF FSR2, ACCESS
1A2E  6ADA     CLRF FSR2H, ACCESS
1A30  50DF     MOVF INDF2, W, ACCESS
1A32  2404     ADDWF 0x4, W, ACCESS
1A34  6ED9     MOVWF FSR2, ACCESS
1A36  6ADA     CLRF FSR2H, ACCESS
1A38  C001     MOVFF __pcstackCOMRAM, INDF2
1A3A  FFDF     NOP
17:            		++fp->count;
1A3C  5003     MOVF fp, W, ACCESS
1A3E  6ED9     MOVWF FSR2, ACCESS
1A40  6ADA     CLRF FSR2H, ACCESS
1A42  0E01     MOVLW 0x1
1A44  26D9     ADDWF FSR2, F, ACCESS
1A46  2ADE     INCF POSTINC2, F, ACCESS
1A48  0E00     MOVLW 0x0
1A4A  22DD     ADDWFC POSTDEC2, F, ACCESS
18:            	}
19:                }
20:                return (unsigned char)c;
21:            }
1A4C  0012     RETURN 0
22:            
23:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/isspace.c  -----------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isspace
4:             
5:             int isspace(int c)
6:             {
7:             	return c == ' ' || (unsigned)c-'\t' < 5;
1BD0  0E01     MOVLW 0x1
1BD2  6E07     MOVWF i, ACCESS
1BD4  0E20     MOVLW 0x20
1BD6  1801     XORWF __pcstackCOMRAM, W, ACCESS
1BD8  1002     IORWF textData, W, ACCESS
1BDA  B4D8     BTFSC STATUS, 2, ACCESS
1BDC  D014     BRA 0x1C06
1BDE  0EF7     MOVLW 0xF7
1BE0  6E03     MOVWF fp, ACCESS
1BE2  0EFF     MOVLW 0xFF
1BE4  6E04     MOVWF 0x4, ACCESS
1BE6  C001     MOVFF __pcstackCOMRAM, product
1BE8  F005     NOP
1BEA  C002     MOVFF textData, lineNum
1BEC  F006     NOP
1BEE  5003     MOVF fp, W, ACCESS
1BF0  2605     ADDWF product, F, ACCESS
1BF2  5004     MOVF 0x4, W, ACCESS
1BF4  2206     ADDWFC lineNum, F, ACCESS
1BF6  5006     MOVF lineNum, W, ACCESS
1BF8  E104     BNZ 0x1C02
1BFA  0E05     MOVLW 0x5
1BFC  5C05     SUBWF product, W, ACCESS
1BFE  A0D8     BTFSS STATUS, 0, ACCESS
1C00  D002     BRA 0x1C06
1C02  0E00     MOVLW 0x0
1C04  6E07     MOVWF i, ACCESS
1C06  C007     MOVFF i, __pcstackCOMRAM
1C08  F001     NOP
1C0A  6A02     CLRF textData, ACCESS
8:             }
1C0C  0012     RETURN 0
9:             
10:            int __isspace_l(int c, locale_t l)
11:            {
12:            	return isspace(c);
13:            }
14:            
15:            weak_alias(__isspace_l, isspace_l);
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/isdigit.c  -----------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isdigit
4:             
5:             int isdigit(int c)
6:             {
7:             	return (unsigned)c-'0' < 10;
1CA6  0ED0     MOVLW 0xD0
1CA8  6E03     MOVWF fp, ACCESS
1CAA  0EFF     MOVLW 0xFF
1CAC  6E04     MOVWF 0x4, ACCESS
1CAE  C001     MOVFF __pcstackCOMRAM, product
1CB0  F005     NOP
1CB2  C002     MOVFF textData, lineNum
1CB4  F006     NOP
1CB6  5003     MOVF fp, W, ACCESS
1CB8  2605     ADDWF product, F, ACCESS
1CBA  5004     MOVF 0x4, W, ACCESS
1CBC  2206     ADDWFC lineNum, F, ACCESS
1CBE  5006     MOVF lineNum, W, ACCESS
1CC0  E106     BNZ 0x1CCE
1CC2  0E0A     MOVLW 0xA
1CC4  5C05     SUBWF product, W, ACCESS
1CC6  B0D8     BTFSC STATUS, 0, ACCESS
1CC8  D002     BRA 0x1CCE
1CCA  0E01     MOVLW 0x1
1CCC  D001     BRA 0x1CD0
1CCE  0E00     MOVLW 0x0
1CD0  6E01     MOVWF __pcstackCOMRAM, ACCESS
1CD2  6A02     CLRF textData, ACCESS
8:             }
1CD4  0012     RETURN 0
9:             
10:            int __isdigit_l(int c, locale_t l)
11:            {
12:            	return isdigit(c);
13:            }
14:            
15:            weak_alias(__isdigit_l, isdigit_l);
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/doprnt.c  ------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
1A4E  A05D     BTFSS flags, 0, ACCESS
78:                    fputs((const char *)buf, fp);
1A52  C00F     MOVFF buf, divisor
1A54  F009     NOP
1A56  C00E     MOVFF neg, fp
1A58  F00A     NOP
1A5A  EC3B     CALL 0x1C76, 0
1A5C  F00E     NOP
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
1A5E  BE11     BTFSC counter, 7, ACCESS
1A60  D005     BRA 0x1A6C
1A62  C010     MOVFF p, n
1A64  F015     NOP
1A66  C011     MOVFF counter, 0x16
1A68  F016     NOP
1A6A  D004     BRA 0x1A74
1A6C  0E00     MOVLW 0x0
1A6E  6E16     MOVWF 0x16, ACCESS
1A70  0E00     MOVLW 0x0
1A72  6E15     MOVWF n, ACCESS
83:                i = 0;
1A74  0E00     MOVLW 0x0
1A76  6E14     MOVWF 0x14, ACCESS
1A78  0E00     MOVLW 0x0
1A7A  6E13     MOVWF quotient, ACCESS
84:                while (i < w) {
1A7C  D00A     BRA 0x1A92
1A92  5015     MOVF n, W, ACCESS
1A94  5C13     SUBWF quotient, W, ACCESS
1A96  5014     MOVF 0x14, W, ACCESS
1A98  0A80     XORLW 0x80
1A9A  6E12     MOVWF sign, ACCESS
1A9C  5016     MOVF 0x16, W, ACCESS
1A9E  0A80     XORLW 0x80
1AA0  5812     SUBWFB sign, W, ACCESS
1AA2  A0D8     BTFSS STATUS, 0, ACCESS
1AA4  D7EC     BRA 0x1A7E
85:                    fputc(' ', fp);
1A7E  0E00     MOVLW 0x0
1A80  6E02     MOVWF textData, ACCESS
1A82  0E20     MOVLW 0x20
1A84  6E01     MOVWF __pcstackCOMRAM, ACCESS
1A86  C00E     MOVFF neg, fp
1A88  F003     NOP
1A8A  ECE7     CALL 0x19CE, 0
1A8C  F00C     NOP
86:                    ++i;
1A8E  4A13     INFSNZ quotient, F, ACCESS
1A90  2A14     INCF 0x14, F, ACCESS
87:                }
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
1AA6  B05D     BTFSC flags, 0, ACCESS
1AA8  D006     BRA 0x1AB6
91:                    fputs((const char *)buf, fp);
1AAA  C00F     MOVFF buf, divisor
1AAC  F009     NOP
1AAE  C00E     MOVFF neg, fp
1AB0  F00A     NOP
1AB2  EC3B     CALL 0x1C76, 0
1AB4  F00E     NOP
92:                }
93:            
94:                return strlen(buf) + w;
1AB6  C00F     MOVFF buf, __pcstackCOMRAM
1AB8  F001     NOP
1ABA  EC94     CALL 0x1D28, 0
1ABC  F00E     NOP
1ABE  5015     MOVF n, W, ACCESS
1AC0  2401     ADDWF __pcstackCOMRAM, W, ACCESS
1AC2  6E0E     MOVWF neg, ACCESS
1AC4  5016     MOVF 0x16, W, ACCESS
1AC6  2002     ADDWFC textData, W, ACCESS
1AC8  6E0F     MOVWF buf, ACCESS
95:            }
1ACA  0012     RETURN 0
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? '0' + d : 'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
265:           
266:               /* Put out padded string */
267:               dbuf[0] = c;
268:               dbuf[1] = '\0';
269:               return pad(fp, &dbuf[0], w);
270:           }
271:           #endif
272:           
273:           #ifdef _VFPF_D
274:           static _INLINE int dtoa(FILE *fp, long long d)
275:           {
276:               int i, p, s, w;
277:               long long n;
278:           
279:               /* Record sign, get absolute value */
280:               n = d;
128A  C01C     MOVFF d, n
281:               s = n < 0 ? 1 : 0;
12AA  AE3B     BTFSS 0x3B, 7, ACCESS
12AC  D002     BRA 0x12B2
12AE  0E01     MOVLW 0x1
12B0  D001     BRA 0x12B4
12B2  0E00     MOVLW 0x0
12B4  6E32     MOVWF s, ACCESS
12B6  6A33     CLRF 0x33, ACCESS
282:               if (s) {
12B8  5032     MOVF s, W, ACCESS
12BA  1033     IORWF 0x33, W, ACCESS
12BC  B4D8     BTFSC STATUS, 2, ACCESS
12BE  D010     BRA 0x12E0
283:                   n = -n;
12C0  1E3B     COMF 0x3B, F, ACCESS
12C2  1E3A     COMF 0x3A, F, ACCESS
12C4  1E39     COMF 0x39, F, ACCESS
12C6  1E38     COMF 0x38, F, ACCESS
12C8  1E37     COMF 0x37, F, ACCESS
12CA  1E36     COMF 0x36, F, ACCESS
12CC  1E35     COMF 0x35, F, ACCESS
12CE  6C34     NEGF n, ACCESS
12D0  0E00     MOVLW 0x0
12D2  2235     ADDWFC 0x35, F, ACCESS
12D4  2236     ADDWFC 0x36, F, ACCESS
12D6  2237     ADDWFC 0x37, F, ACCESS
12D8  2238     ADDWFC 0x38, F, ACCESS
12DA  2239     ADDWFC 0x39, F, ACCESS
12DC  223A     ADDWFC 0x3A, F, ACCESS
12DE  223B     ADDWFC 0x3B, F, ACCESS
284:               }
285:           
286:               /* Adjust flags, precision, width */
287:               if (!(prec < 0)) {
12E0  0100     MOVLB 0x0
12E2  AF65     BTFSS 0x65, 7, BANKED
288:                   flags &= ~ZERO_FLAG;
12E4  925D     BCF flags, 1, ACCESS
289:               }
290:               p = (0 < prec) ? prec : 1;
12E6  BF65     BTFSC 0x65, 7, BANKED
12E8  D005     BRA 0x12F4
12EA  5165     MOVF 0x65, W, BANKED
12EC  E108     BNZ 0x12FE
12EE  0564     DECF prec, W, BANKED
12F0  B0D8     BTFSC STATUS, 0, ACCESS
12F2  D005     BRA 0x12FE
12F4  0E00     MOVLW 0x0
12F6  6E2F     MOVWF 0x2F, ACCESS
12F8  0E01     MOVLW 0x1
12FA  6E2E     MOVWF p, ACCESS
12FC  D004     BRA 0x1306
12FE  C064     MOVFF prec, p
1300  F02E     NOP
1302  C065     MOVFF 0x65, 0x2F
1304  F02F     NOP
291:               w = width;
1306  C062     MOVFF width, w
1308  F030     NOP
130A  C063     MOVFF ttemp6, 0x31
130C  F031     NOP
292:               if (s || (flags & PLUS_FLAG)) {
130E  5032     MOVF s, W, ACCESS
1310  1033     IORWF 0x33, W, ACCESS
1312  A4D8     BTFSS STATUS, 2, ACCESS
1314  D002     BRA 0x131A
1316  A45D     BTFSS flags, 2, ACCESS
1318  D003     BRA 0x1320
293:                   --w;
131A  0630     DECF w, F, ACCESS
131C  A0D8     BTFSS STATUS, 0, ACCESS
131E  0631     DECF 0x31, F, ACCESS
294:               }
295:           
296:               /* Convert to decimal, possibly filling on the left with zeroes */
297:               i = sizeof(dbuf) - 1;
1320  0E00     MOVLW 0x0
1322  6E3D     MOVWF 0x3D, ACCESS
1324  0E1F     MOVLW 0x1F
1326  6E3C     MOVWF i, ACCESS
298:               dbuf[i] = '\0';
1328  0E00     MOVLW 0x0
132A  6F86     MOVWF 0x86, BANKED
299:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
132C  D07A     BRA 0x1422
1422  BE3D     BTFSC 0x3D, 7, ACCESS
1424  D01F     BRA 0x1464
1426  503D     MOVF 0x3D, W, ACCESS
1428  E103     BNZ 0x1430
142A  043C     DECF i, W, ACCESS
142C  A0D8     BTFSS STATUS, 0, ACCESS
142E  D01A     BRA 0x1464
1430  5034     MOVF n, W, ACCESS
1432  1035     IORWF 0x35, W, ACCESS
1434  1036     IORWF 0x36, W, ACCESS
1436  1037     IORWF 0x37, W, ACCESS
1438  1038     IORWF 0x38, W, ACCESS
143A  1039     IORWF 0x39, W, ACCESS
143C  103A     IORWF 0x3A, W, ACCESS
143E  103B     IORWF 0x3B, W, ACCESS
1440  A4D8     BTFSS STATUS, 2, ACCESS
1442  D775     BRA 0x132E
1444  BE2F     BTFSC 0x2F, 7, ACCESS
1446  D005     BRA 0x1452
1448  502F     MOVF 0x2F, W, ACCESS
144A  E102     BNZ 0x1450
144C  042E     DECF p, W, ACCESS
144E  B0D8     BTFSC STATUS, 0, ACCESS
1450  D76E     BRA 0x132E
1452  BE31     BTFSC 0x31, 7, ACCESS
1454  D007     BRA 0x1464
1456  5031     MOVF 0x31, W, ACCESS
1458  E103     BNZ 0x1460
145A  0430     DECF w, W, ACCESS
145C  A0D8     BTFSS STATUS, 0, ACCESS
145E  D002     BRA 0x1464
1460  B25D     BTFSC flags, 1, ACCESS
1462  D765     BRA 0x132E
300:                   --i;
132E  063C     DECF i, F, ACCESS
1330  A0D8     BTFSS STATUS, 0, ACCESS
1332  063D     DECF 0x3D, F, ACCESS
301:                   dbuf[i] = '0' + abs(n % 10);
1334  503C     MOVF i, W, ACCESS
1336  0F67     ADDLW 0x67
1338  6ED9     MOVWF FSR2, ACCESS
133A  6ADA     CLRF FSR2H, ACCESS
133C  C034     MOVFF n, __pcstackCOMRAM
133E  F001     NOP
1340  C035     MOVFF 0x35, textData
1342  F002     NOP
1344  C036     MOVFF 0x36, fp
1346  F003     NOP
1348  C037     MOVFF 0x37, 0x4
134A  F004     NOP
134C  C038     MOVFF 0x38, product
134E  F005     NOP
1350  C039     MOVFF 0x39, lineNum
1352  F006     NOP
1354  C03A     MOVFF 0x3A, i
1356  F007     NOP
1358  C03B     MOVFF 0x3B, s
135A  F008     NOP
135C  0E0A     MOVLW 0xA
135E  6E09     MOVWF divisor, ACCESS
1360  0E00     MOVLW 0x0
1362  6E0A     MOVWF fp, ACCESS
1364  0E00     MOVLW 0x0
1366  6E0B     MOVWF c, ACCESS
1368  0E00     MOVLW 0x0
136A  6E0C     MOVWF i, ACCESS
136C  0E00     MOVLW 0x0
136E  6E0D     MOVWF 0xD, ACCESS
1370  0E00     MOVLW 0x0
1372  6E0E     MOVWF neg, ACCESS
1374  0E00     MOVLW 0x0
1376  6E0F     MOVWF buf, ACCESS
1378  0E00     MOVLW 0x0
137A  6E10     MOVWF p, ACCESS
137C  EC9F     CALL 0x173E, 0
137E  F00B     NOP
1380  C001     MOVFF __pcstackCOMRAM, 0x24
1382  F024     NOP
1384  C002     MOVFF textData, 0x25
1386  F025     NOP
1388  C003     MOVFF fp, 0x26
138A  F026     NOP
138C  C004     MOVFF 0x4, 0x27
138E  F027     NOP
1390  C005     MOVFF product, 0x28
1392  F028     NOP
1394  C006     MOVFF lineNum, 0x29
1396  F029     NOP
1398  C007     MOVFF i, 0x2A
139A  F02A     NOP
139C  C008     MOVFF s, 0x2B
139E  F02B     NOP
13A0  C024     MOVFF 0x24, quotient
13A2  F013     NOP
13A4  C026     MOVFF 0x26, 0x14
13A6  F014     NOP
13A8  EC22     CALL 0x1C44, 0
13AA  F00E     NOP
13AC  5013     MOVF quotient, W, ACCESS
13AE  0F30     ADDLW 0x30
13B0  6EDF     MOVWF INDF2, ACCESS
302:                   --p;
13B2  062E     DECF p, F, ACCESS
13B4  A0D8     BTFSS STATUS, 0, ACCESS
13B6  062F     DECF 0x2F, F, ACCESS
303:                   --w;
13B8  0630     DECF w, F, ACCESS
13BA  A0D8     BTFSS STATUS, 0, ACCESS
13BC  0631     DECF 0x31, F, ACCESS
304:                   n = n / 10;
13BE  C034     MOVFF n, __pcstackCOMRAM
13C0  F001     NOP
13C2  C035     MOVFF 0x35, textData
13C4  F002     NOP
13C6  C036     MOVFF 0x36, fp
13C8  F003     NOP
13CA  C037     MOVFF 0x37, 0x4
13CC  F004     NOP
13CE  C038     MOVFF 0x38, product
13D0  F005     NOP
13D2  C039     MOVFF 0x39, lineNum
13D4  F006     NOP
13D6  C03A     MOVFF 0x3A, i
13D8  F007     NOP
13DA  C03B     MOVFF 0x3B, s
13DC  F008     NOP
13DE  0E0A     MOVLW 0xA
13E0  6E09     MOVWF divisor, ACCESS
13E2  0E00     MOVLW 0x0
13E4  6E0A     MOVWF fp, ACCESS
13E6  0E00     MOVLW 0x0
13E8  6E0B     MOVWF c, ACCESS
13EA  0E00     MOVLW 0x0
13EC  6E0C     MOVWF i, ACCESS
13EE  0E00     MOVLW 0x0
13F0  6E0D     MOVWF 0xD, ACCESS
13F2  0E00     MOVLW 0x0
13F4  6E0E     MOVWF neg, ACCESS
13F6  0E00     MOVLW 0x0
13F8  6E0F     MOVWF buf, ACCESS
13FA  0E00     MOVLW 0x0
13FC  6E10     MOVWF p, ACCESS
13FE  EC5D     CALL 0x14BA, 0
1400  F00A     NOP
1402  C001     MOVFF __pcstackCOMRAM, n
1404  F034     NOP
1406  C002     MOVFF textData, 0x35
1408  F035     NOP
140A  C003     MOVFF fp, 0x36
140C  F036     NOP
140E  C004     MOVFF 0x4, 0x37
1410  F037     NOP
1412  C005     MOVFF product, 0x38
1414  F038     NOP
1416  C006     MOVFF lineNum, 0x39
1418  F039     NOP
141A  C007     MOVFF i, 0x3A
141C  F03A     NOP
141E  C008     MOVFF s, 0x3B
1420  F03B     NOP
305:               }
306:           
307:               /* Display sign if required */
308:               if (s || (flags & PLUS_FLAG)) {
1464  5032     MOVF s, W, ACCESS
1466  1033     IORWF 0x33, W, ACCESS
1468  A4D8     BTFSS STATUS, 2, ACCESS
146A  D002     BRA 0x1470
146C  A45D     BTFSS flags, 2, ACCESS
146E  D015     BRA 0x149A
309:                   --i;
1470  063C     DECF i, F, ACCESS
1472  A0D8     BTFSS STATUS, 0, ACCESS
1474  063D     DECF 0x3D, F, ACCESS
310:                   dbuf[i] = s ? '-' : '+';
1476  5032     MOVF s, W, ACCESS
1478  1033     IORWF 0x33, W, ACCESS
147A  A4D8     BTFSS STATUS, 2, ACCESS
147C  D004     BRA 0x1486
147E  0E00     MOVLW 0x0
1480  6E2D     MOVWF 0x2D, ACCESS
1482  0E2B     MOVLW 0x2B
1484  D003     BRA 0x148C
1486  0E00     MOVLW 0x0
1488  6E2D     MOVWF 0x2D, ACCESS
148A  0E2D     MOVLW 0x2D
148C  6E2C     MOVWF 0x2C, ACCESS
148E  503C     MOVF i, W, ACCESS
1490  0F67     ADDLW 0x67
1492  6ED9     MOVWF FSR2, ACCESS
1494  6ADA     CLRF FSR2H, ACCESS
1496  C02C     MOVFF 0x2C, INDF2
1498  FFDF     NOP
311:               }
312:           
313:               /* Put out padded string */
314:               return pad(fp, &dbuf[i], w);
149A  C01B     MOVFF fp, neg
149C  F00E     NOP
149E  503C     MOVF i, W, ACCESS
14A0  0F67     ADDLW 0x67
14A2  6E0F     MOVWF buf, ACCESS
14A4  C030     MOVFF w, p
14A6  F010     NOP
14A8  C031     MOVFF 0x31, counter
14AA  F011     NOP
14AC  EC27     CALL 0x1A4E, 0
14AE  F00D     NOP
14B0  C00E     MOVFF neg, fp
14B2  F01B     NOP
14B4  C00F     MOVFF buf, d
14B6  F01C     NOP
315:           }
14B8  0012     RETURN 0
316:           #endif
317:           
318:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
319:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
320:           {
321:               char mode, nmode;
322:               int d, e, i, m, n, ne, p, pp, sign, t, w;
323:               long double g, h, l, ou, u;
324:           
325:               /* Record sign, get absolute value */
326:               sign = 0;
327:               g = f;
328:               if (g < 0.0) {
329:                   sign = 1;
330:                   g = -g;
331:               }
332:           
333:               /* Print sign */
334:               n = 0;
335:               w = width;
336:               if (sign || (flags & PLUS_FLAG)) {
337:                   dbuf[n] = sign ? '-' : '+';
338:                   ++n;
339:                   --w;
340:               }
341:           
342:               /* Catch infinities, NaNs here */
343:               if (isinf(g)) {
344:                   if (isupper((int)c)) {
345:                       strcpy(&dbuf[n], "INF");
346:                   } else {
347:                       strcpy(&dbuf[n], "inf");
348:                   }
349:                   w -= CSTRLEN("inf");
350:                   return pad(fp, &dbuf[0], w);
351:               }
352:               if (isnan(g)) {
353:                   if (isupper((int)c)) {
354:                       strcpy(&dbuf[n], "NAN");
355:                   } else {
356:                       strcpy(&dbuf[n], "nan");
357:                   }
358:                   w -= CSTRLEN("inf");
359:                   return pad(fp, &dbuf[0], w);
360:               }
361:           
362:               /* First find the largest power of 10 not larger than number to print */
363:               u = 1.0;
364:               e = 0;
365:               if (!(g == 0.0)) {
366:                   while (!(g < (u*10.0))) {
367:                       u = u*10.0;
368:                       ++e;
369:                   }
370:                   while (g < u) {
371:                       u = u/10.0;
372:                       --e;
373:                   }
374:               }
375:           
376:               /* Get mode, precision */
377:               mode = tolower((int)c);
378:               nmode = mode;
379:               if (mode == 'g') {
380:           		if (prec == 0) {
381:           			prec = 1;
382:           		}
383:                   p = (0 < prec) ? prec : 6;
384:               } else {
385:                   p = (prec < 0) ? 6 : prec;
386:               }
387:           
388:               /* Choose e or f mode from g mode */
389:               if (mode == 'g') {
390:                   if (!(e < -4) && !((p - 1) < e)) {
391:                       nmode = 'f';
392:                   } else {
393:                       nmode = 'e';
394:                   }
395:               }
396:           
397:               /* Decimal places or significant digits */
398:               m = p;
399:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
400:                   ++m;
401:               }
402:           
403:               /* Adjust starting exponent, string length for 'f' conversions */
404:               if (nmode == 'f') {
405:                   if (e < 0) {
406:                       u = 1.0;
407:                       e = 0;
408:                   }
409:                   if (!(mode == 'g')) {
410:                       m += e;
411:                   }
412:               }
413:           
414:               /* Go through the conversion once to get to the rounding step */
415:               i = 0;
416:               h = g;
417:               ou = u;
418:               while (i < m) {
419:                   l = floor(h/u);
420:                   d = (int)l;
421:                   h -= l*u;
422:                   u = u/10.0;
423:                   ++i;
424:               }
425:               
426:               /* Remainder >= halfway ? */
427:               l = u*5.0;
428:               if (h < l) {
429:                   l = 0.0;
430:               } else {
431:                   /* On tie choose even number */
432:                   if ((h == l) && !(d % 2)) {
433:                       l = 0.0;
434:                   }
435:               }
436:           
437:               /* Round */
438:               h = g + l;
439:               
440:               /* Convert again, after rounding */
441:               u = ou;
442:               ne = (nmode == 'e') ? 0 : e;
443:               pp = 0;
444:               t = 0;
445:               i = 0;
446:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
447:                   l = floor(h/u);
448:                   d = (int)l;
449:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
450:                       ++t;
451:                   } else {
452:                       if (!pp && (ne < 0)) {
453:                           dbuf[n++] = '.';
454:                           --w;
455:                           pp = 1;
456:                       }
457:                       while (t) {
458:                           dbuf[n++] = '0';
459:                           --w;
460:                           --t;
461:                       }
462:                       dbuf[n++] = '0' + d;
463:                       --w;
464:                   }
465:                   h -= l*u;
466:                   u = u/10.0;
467:                   --ne;
468:                   ++i;
469:               }
470:               if (!pp && (flags & POUND_FLAG)) {
471:                   dbuf[n++] = '.';
472:               }
473:               dbuf[n] = '\0';
474:           
475:               /* Convert exponent */
476:               if (nmode == 'e') {
477:                   i = sizeof(dbuf) - 1;
478:                   dbuf[i] = '\0';
479:                   sign = 0;
480:                   if (e < 0) {
481:                       sign = 1;
482:                       e = -e;
483:                   }
484:                   p = 2;
485:                   while (e || (0 < p)) {
486:                       --i;
487:                       dbuf[i] = '0' + (e % 10);
488:                       e = e / 10;
489:                       --p;
490:                       --w;
491:                   }
492:                   --i;
493:                   dbuf[i] = sign ? '-' : '+';
494:                   --w;
495:                   --i;
496:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
497:                   --w;
498:                   strcpy(&dbuf[n], &dbuf[i]);
499:               }
500:           
501:               /* Put out padded string */
502:               return pad(fp, &dbuf[0], w);
503:           }
504:           #endif
505:           
506:           #ifdef _VFPF_O
507:           static _INLINE int otoa(FILE *fp, unsigned long long d)
508:           {
509:               int i, p, t, w;
510:               unsigned long long n;
511:           
512:               /* Adjust flags, precision, width */
513:               if (!(prec < 0)) {
514:                   flags &= ~ZERO_FLAG;
515:               }
516:               p = (0 < prec) ? prec : 1;
517:               w = width;
518:           
519:               /* Convert to octal, possibly filling on the left with zeroes */
520:               n = d;
521:               i = sizeof(dbuf) - 1;
522:               dbuf[i] = '\0';
523:               t = 0;
524:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
525:                   --i;
526:                   t = n & 07;
527:                   dbuf[i] = '0' + t;
528:                   --p;
529:                   --w;
530:                   n = n >> 3;
531:               }
532:           
533:               /* Display prefix if required */
534:               if ((flags & POUND_FLAG) && t) {
535:                   --i;
536:                   dbuf[i] = '0';
537:                   --w;
538:               }
539:           
540:               /* Put out padded string */
541:               return pad(fp, &dbuf[i], w);
542:           }
543:           #endif
544:           
545:           #ifdef _VFPF_S
546:           static _INLINE int stoa(FILE *fp, char *s)
547:           {
548:               char *cp, nuls[] = "(null)";
549:               int i, l, p, w;
550:           
551:               /* Check for null string */
552:               cp = s;
553:               if (!cp) {
554:                   cp = nuls;
555:               }
556:           
557:               /* Get length, precision, width */
558:               l = strlen(cp);
559:               p = prec;
560:               l = (!(p < 0) && (p < l)) ? p : l;
561:               p = l;
562:               w = width;
563:           
564:               /* Right justify, pad on left ? */
565:               if (!(flags & MINUS_FLAG)) {
566:                   while (l < w) {
567:                       fputc(' ', fp);
568:                       ++l;
569:                   }
570:               }
571:           
572:               /* Put out string */
573:               i = 0;
574:               while (i < p) {
575:                   fputc(*cp, fp);
576:                   ++cp;
577:                   ++i;
578:               }
579:           
580:               /* Left justify, pad on right ? */
581:               if (flags & MINUS_FLAG) {
582:                   while (l < w) {
583:                       fputc(' ', fp);
584:                       ++l;
585:                   }
586:               }
587:           
588:               return l;
589:           }
590:           #endif
591:           
592:           #ifdef _VFPF_U
593:           static _INLINE int utoa(FILE *fp, unsigned long long d)
594:           {
595:               int i, p, w;
596:               unsigned long long n;
597:           
598:               /* Adjust flags, precision, width */
599:               if (!(prec < 0)) {
600:                   flags &= ~ZERO_FLAG;
601:               }
602:               p = (0 < prec) ? prec : 1;
603:               w = width;
604:           
605:               /* Convert to decimal, possibly filling on the left with zeroes */
606:               n = d;
607:               i = sizeof(dbuf) - 1;
608:               dbuf[i] = '\0';
609:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
610:                   --i;
611:                   dbuf[i] = '0' + (n % 10);
612:                   --p;
613:                   --w;
614:                   n = n / 10;
615:               }
616:           
617:               /* Put out padded string */
618:               return pad(fp, &dbuf[i], w);
619:           }
620:           #endif
621:           
622:           #if defined(_VFPF_X) || defined(_VFPF_P)
623:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
624:           {
625:               int c, i, p, w;
626:               unsigned long long n;
627:           
628:               /* Adjust, flags, precision, width */
629:               if (!(prec < 0)) {
630:                   flags &= ~ZERO_FLAG;
631:               }
632:               p = (0 < prec) ? prec : 1;
633:               w = width;
634:               if (flags & POUND_FLAG) {
635:                   w -= 2;
636:               }
637:           
638:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
639:               n = d;
640:               i = sizeof(dbuf) - 1;
641:               dbuf[i] = '\0';
642:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
643:                   --i;
644:                   c = n & 0x0f;
645:                   c = (c < 10) ? '0' + c : 'a' + (c - 10);
646:                   if (isupper((int)x) && isalpha(c)) {
647:                       c = toupper(c);
648:                   }
649:                   dbuf[i] = (char)c;
650:                   --p;
651:                   --w;
652:                   n = n >> 4;
653:               }
654:           
655:               /* Display prefix if required */
656:               if (flags & POUND_FLAG) {
657:                   --i;
658:                   dbuf[i] = x;
659:                   --i;
660:                   dbuf[i] = '0';
661:               }
662:           
663:               /* Put out padded string */
664:               return pad(fp, &dbuf[i], w);
665:           }
666:           #endif
667:           
668:           /* Consume and convert the next part of the format string */
669:           #ifdef _VFPF_CONVERT
670:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
671:           {
672:               char c, *cp, ct[3];
673:               int done, i;
674:               long long ll;
675:               unsigned long long llu;
676:               long double f;
677:               void *vp;
678:           
679:               /* Conversion ? */
680:               if ((*fmt)[0] == '%') {
1028  503F     MOVF fmt, W, ACCESS
681:                   ++*fmt;
1040  503F     MOVF fmt, W, ACCESS
1042  6ED9     MOVWF FSR2, ACCESS
1044  6ADA     CLRF FSR2H, ACCESS
1046  2ADF     INCF INDF2, F, ACCESS
682:           
683:                   flags = width = 0;
1048  0E00     MOVLW 0x0
104A  6F63     MOVWF ttemp6, BANKED
104C  0E00     MOVLW 0x0
104E  6F62     MOVWF width, BANKED
1050  C062     MOVFF width, flags
1052  F05D     NOP
1054  C063     MOVFF ttemp6, 0x5E
1056  F05E     NOP
684:                   prec = -1;
1058  6964     SETF prec, BANKED
105A  6965     SETF 0x65, BANKED
685:           
686:           #ifdef _VFPF_FLAGS
687:                   /* Get flags */
688:                   done = 0;
105C  0E00     MOVLW 0x0
105E  6E4E     MOVWF 0x4E, ACCESS
1060  0E00     MOVLW 0x0
1062  D011     BRA 0x1086
689:                   while (!done) {
10CA  504D     MOVF done, W, ACCESS
10CC  104E     IORWF 0x4E, W, ACCESS
10CE  B4D8     BTFSC STATUS, 2, ACCESS
10D0  D7DC     BRA 0x108A
690:                       switch ((*fmt)[0]) {
691:                           case '-' :
692:                               flags |= MINUS_FLAG;
1064  805D     BSF flags, 0, ACCESS
693:                               ++*fmt;
1066  503F     MOVF fmt, W, ACCESS
1068  6ED9     MOVWF FSR2, ACCESS
106A  6ADA     CLRF FSR2H, ACCESS
106C  2ADF     INCF INDF2, F, ACCESS
694:                               break;
106E  D02D     BRA 0x10CA
695:                           case '0' :
696:                               flags |= ZERO_FLAG;
1070  825D     BSF flags, 1, ACCESS
1072  D7F9     BRA 0x1066
697:                               ++*fmt;
698:                               break;
699:                           case '+' :
700:                               flags |= PLUS_FLAG;
1074  845D     BSF flags, 2, ACCESS
1076  D7F7     BRA 0x1066
701:                               ++*fmt;
702:                               break;
703:                           case ' ' :
704:                               flags |= SPACE_FLAG;
1078  865D     BSF flags, 3, ACCESS
107A  D7F5     BRA 0x1066
705:                               ++*fmt;
706:                               break;
707:                           case '#' :
708:                               flags |= POUND_FLAG;
107C  885D     BSF flags, 4, ACCESS
107E  D7F3     BRA 0x1066
709:                               ++*fmt;
710:                               break;
711:                           default:
712:                               done = 1;
1080  0E00     MOVLW 0x0
1082  6E4E     MOVWF 0x4E, ACCESS
1084  0E01     MOVLW 0x1
1086  6E4D     MOVWF done, ACCESS
713:                               break;
1088  D020     BRA 0x10CA
714:                       }
108A  503F     MOVF fmt, W, ACCESS
108C  6ED9     MOVWF FSR2, ACCESS
108E  6ADA     CLRF FSR2H, ACCESS
1090  CFDF     MOVFF INDF2, TBLPTR
1092  FFF6     NOP
1094  0E10     MOVLW 0x10
1096  6EF7     MOVWF TBLPTRH, ACCESS
1098  0008     TBLRD*
109A  50F5     MOVF TABLAT, W, ACCESS
109C  6E41     MOVWF 0x41, ACCESS
109E  6A42     CLRF 0x42, ACCESS
10A0  5042     MOVF 0x42, W, ACCESS
10A2  0A00     XORLW 0x0
10A4  A4D8     BTFSS STATUS, 2, ACCESS
10A6  D7EC     BRA 0x1080
10A8  5041     MOVF 0x41, W, ACCESS
10AA  0A20     XORLW 0x20
10AC  B4D8     BTFSC STATUS, 2, ACCESS
10AE  D7E4     BRA 0x1078
10B0  0A03     XORLW 0x3
10B2  B4D8     BTFSC STATUS, 2, ACCESS
10B4  D7E3     BRA 0x107C
10B6  0A08     XORLW 0x8
10B8  B4D8     BTFSC STATUS, 2, ACCESS
10BA  D7DC     BRA 0x1074
10BC  0A06     XORLW 0x6
10BE  B4D8     BTFSC STATUS, 2, ACCESS
10C0  D7D1     BRA 0x1064
10C2  0A1D     XORLW 0x1D
10C4  B4D8     BTFSC STATUS, 2, ACCESS
10C6  D7D4     BRA 0x1070
10C8  D7DB     BRA 0x1080
715:                   }
716:                   if (flags & MINUS_FLAG) {
10D2  B05D     BTFSC flags, 0, ACCESS
717:                       flags &= ~ZERO_FLAG;
10D4  925D     BCF flags, 1, ACCESS
718:                   }
719:           #endif
720:           
721:           #ifdef _VFPF_WIDTH
722:                   /* Get field width */
723:                   if ((*fmt)[0] == '*') {
10D6  503F     MOVF fmt, W, ACCESS
10D8  6ED9     MOVWF FSR2, ACCESS
10DA  6ADA     CLRF FSR2H, ACCESS
10DC  CFDF     MOVFF INDF2, TBLPTR
10DE  FFF6     NOP
10E0  0E10     MOVLW 0x10
10E2  6EF7     MOVWF TBLPTRH, ACCESS
10E4  0008     TBLRD*
10E6  50F5     MOVF TABLAT, W, ACCESS
10E8  0A2A     XORLW 0x2A
10EA  A4D8     BTFSS STATUS, 2, ACCESS
10EC  D018     BRA 0x111E
724:                       ++*fmt;
10EE  503F     MOVF fmt, W, ACCESS
10F0  6ED9     MOVWF FSR2, ACCESS
10F2  6ADA     CLRF FSR2H, ACCESS
10F4  2ADF     INCF INDF2, F, ACCESS
725:                       width = va_arg(ap, int);
10F6  5040     MOVF ap, W, ACCESS
10F8  6ED9     MOVWF FSR2, ACCESS
10FA  6ADA     CLRF FSR2H, ACCESS
10FC  0E02     MOVLW 0x2
10FE  26DF     ADDWF INDF2, F, ACCESS
1100  5CDF     SUBWF INDF2, W, ACCESS
1102  6ED9     MOVWF FSR2, ACCESS
1104  6ADA     CLRF FSR2H, ACCESS
1106  CFDE     MOVFF POSTINC2, width
1108  F062     NOP
110A  CFDE     MOVFF POSTINC2, ttemp6
110C  F063     NOP
726:                       if (width < 0) {
110E  AF63     BTFSS ttemp6, 7, BANKED
1110  D038     BRA 0x1182
727:                           flags |= MINUS_FLAG;
1112  805D     BSF flags, 0, ACCESS
728:                           width = -width;
1114  6D62     NEGF width, BANKED
1116  1F63     COMF ttemp6, F, BANKED
1118  B0D8     BTFSC STATUS, 0, ACCESS
111A  2B63     INCF ttemp6, F, BANKED
111C  D032     BRA 0x1182
729:                       }
730:                   } else {
731:                       width = atoi(*fmt);
111E  503F     MOVF fmt, W, ACCESS
1120  6ED9     MOVWF FSR2, ACCESS
1122  6ADA     CLRF FSR2H, ACCESS
1124  50DF     MOVF INDF2, W, ACCESS
1126  6E08     MOVWF s, ACCESS
1128  EC01     CALL 0x1602, 0
112A  F00B     NOP
112C  C008     MOVFF s, width
112E  F062     NOP
1130  C009     MOVFF divisor, ttemp6
1132  F063     NOP
732:                       while (isdigit((*fmt)[0])) {
1134  D004     BRA 0x113E
113E  0ED0     MOVLW 0xD0
1140  6E41     MOVWF 0x41, ACCESS
1142  0EFF     MOVLW 0xFF
1144  6E42     MOVWF 0x42, ACCESS
1146  503F     MOVF fmt, W, ACCESS
1148  6ED9     MOVWF FSR2, ACCESS
114A  6ADA     CLRF FSR2H, ACCESS
114C  CFDF     MOVFF INDF2, TBLPTR
114E  FFF6     NOP
1150  0E10     MOVLW 0x10
1152  6EF7     MOVWF TBLPTRH, ACCESS
1154  0008     TBLRD*
1156  50F5     MOVF TABLAT, W, ACCESS
1158  6E43     MOVWF 0x43, ACCESS
115A  6A44     CLRF 0x44, ACCESS
115C  5041     MOVF 0x41, W, ACCESS
115E  2643     ADDWF 0x43, F, ACCESS
1160  5042     MOVF 0x42, W, ACCESS
1162  2244     ADDWFC 0x44, F, ACCESS
1164  5044     MOVF 0x44, W, ACCESS
1166  E106     BNZ 0x1174
1168  0E0A     MOVLW 0xA
116A  5C43     SUBWF 0x43, W, ACCESS
116C  B0D8     BTFSC STATUS, 0, ACCESS
116E  D002     BRA 0x1174
1170  0E01     MOVLW 0x1
1172  D001     BRA 0x1176
1174  0E00     MOVLW 0x0
1176  6E4F     MOVWF 0x4F, ACCESS
1178  6A50     CLRF 0x50, ACCESS
117A  504F     MOVF 0x4F, W, ACCESS
117C  1050     IORWF 0x50, W, ACCESS
117E  A4D8     BTFSS STATUS, 2, ACCESS
1180  D7DA     BRA 0x1136
733:                           ++*fmt;
1136  503F     MOVF fmt, W, ACCESS
1138  6ED9     MOVWF FSR2, ACCESS
113A  6ADA     CLRF FSR2H, ACCESS
113C  2ADF     INCF INDF2, F, ACCESS
734:                       }
735:                   }
736:           #endif
737:           
738:           #ifdef _VFPF_PRECISION
739:                   /* Get precision */
740:                   if ((*fmt)[0] == '.') {
741:                       prec = 0;
742:                       ++*fmt;
743:                       if ((*fmt)[0] == '*') {
744:                           ++*fmt;
745:                           prec = va_arg(ap, int);
746:                       } else {
747:                           prec = atoi(*fmt);
748:                           while (isdigit((*fmt)[0])) {
749:                               ++*fmt;
750:                           }
751:                       }
752:                   }
753:           #endif
754:           
755:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
756:                   /* Case-folded conversion types */
757:                   ct[0] = tolower((int)(*fmt)[0]);
758:                   if (ct[0]) {
759:                       ct[1] = tolower((int)(*fmt)[1]);
760:                       if (ct[1]) {
761:                           ct[2] = tolower((int)(*fmt)[2]);
762:                       }
763:                   }
764:           #endif
765:           
766:           #ifdef _VFPF_A
767:                   /* 'a' style (hex) floating point */
768:                   if (ct[0] == 'a') {
769:           
770:                       c = (*fmt)[0];
771:                       ++*fmt;
772:                       f = (long double)va_arg(ap, double);
773:                                   
774:                       return atoa(fp, f, c);
775:                   }
776:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
777:           
778:                       c = (*fmt)[1];
779:                       if (isupper((int)(*fmt)[0])) {
780:                           f = va_arg(ap, long double);
781:                       } else {
782:                           f = (long double)va_arg(ap, double);
783:                       }
784:                       *fmt += CSTRLEN("la");
785:                                   
786:                       return atoa(fp, f, c);
787:                   }
788:           #endif
789:           
790:           #ifdef _VFPF_C
791:                   /* Character */
792:                   if (*fmt[0] == 'c') {
793:                       ++*fmt;
794:                       c = (unsigned char)va_arg(ap, int);
795:                       return ctoa(fp, c);
796:                   }
797:           #endif
798:           
799:           #ifdef _VFPF_D
800:           #ifdef _VFPF_HH
801:                   /* Character decimal integer */
802:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
803:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
804:           
805:                       *fmt += CSTRLEN("hhd");
806:                       ll = (long long)(signed char)va_arg(ap, int);
807:                                   
808:                       return dtoa(fp, ll);
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_H
813:                   /* Short decimal integer */
814:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
815:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
816:           
817:                       *fmt += CSTRLEN("hd");
818:                       ll = (long long)(short)va_arg(ap, int);
819:                                   
820:                       return dtoa(fp, ll);
821:                   }
822:           #endif
823:           
824:                   /* Decimal integer */
825:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
1182  503F     MOVF fmt, W, ACCESS
1184  6ED9     MOVWF FSR2, ACCESS
1186  6ADA     CLRF FSR2H, ACCESS
1188  CFDF     MOVFF INDF2, TBLPTR
118A  FFF6     NOP
118C  0E10     MOVLW 0x10
118E  6EF7     MOVWF TBLPTRH, ACCESS
1190  0008     TBLRD*
1192  50F5     MOVF TABLAT, W, ACCESS
1194  0A64     XORLW 0x64
1196  B4D8     BTFSC STATUS, 2, ACCESS
1198  D00C     BRA 0x11B2
119A  503F     MOVF fmt, W, ACCESS
119C  6ED9     MOVWF FSR2, ACCESS
119E  6ADA     CLRF FSR2H, ACCESS
11A0  CFDF     MOVFF INDF2, TBLPTR
11A2  FFF6     NOP
11A4  0E10     MOVLW 0x10
11A6  6EF7     MOVWF TBLPTRH, ACCESS
11A8  0008     TBLRD*
11AA  50F5     MOVF TABLAT, W, ACCESS
11AC  0A69     XORLW 0x69
11AE  A4D8     BTFSS STATUS, 2, ACCESS
11B0  D032     BRA 0x1216
826:           
827:                       ++*fmt;
11B2  503F     MOVF fmt, W, ACCESS
11B4  6ED9     MOVWF FSR2, ACCESS
11B6  6ADA     CLRF FSR2H, ACCESS
11B8  2ADF     INCF INDF2, F, ACCESS
828:                       ll = (long long)va_arg(ap, int);
11BA  5040     MOVF ap, W, ACCESS
11BC  6ED9     MOVWF FSR2, ACCESS
11BE  6ADA     CLRF FSR2H, ACCESS
11C0  50DF     MOVF INDF2, W, ACCESS
11C2  2ADF     INCF INDF2, F, ACCESS
11C4  2ADF     INCF INDF2, F, ACCESS
11C6  6ED9     MOVWF FSR2, ACCESS
11C8  6ADA     CLRF FSR2H, ACCESS
11CA  CFDE     MOVFF POSTINC2, ll
11CC  F045     NOP
11CE  CFDD     MOVFF POSTDEC2, 0x46
11D0  F046     NOP
11D2  0E00     MOVLW 0x0
11D4  BE46     BTFSC 0x46, 7, ACCESS
11D6  0EFF     MOVLW 0xFF
11D8  6E47     MOVWF 0x47, ACCESS
11DA  6E48     MOVWF 0x48, ACCESS
11DC  6E49     MOVWF 0x49, ACCESS
11DE  6E4A     MOVWF 0x4A, ACCESS
11E0  6E4B     MOVWF 0x4B, ACCESS
11E2  6E4C     MOVWF 0x4C, ACCESS
829:                                   
830:                       return dtoa(fp, ll);
11E4  C03E     MOVFF fp, fp
11E6  F01B     NOP
11E8  C045     MOVFF ll, d
11EA  F01C     NOP
11EC  C046     MOVFF 0x46, 0x1D
11EE  F01D     NOP
11F0  C047     MOVFF 0x47, 0x1E
11F2  F01E     NOP
11F4  C048     MOVFF 0x48, 0x1F
11F6  F01F     NOP
11F8  C049     MOVFF 0x49, 0x20
11FA  F020     NOP
11FC  C04A     MOVFF 0x4A, 0x21
11FE  F021     NOP
1200  C04B     MOVFF 0x4B, 0x22
1202  F022     NOP
1204  C04C     MOVFF 0x4C, 0x23
1206  F023     NOP
1208  EC45     CALL 0x128A, 0
120A  F009     NOP
120C  C01B     MOVFF fp, fp
120E  F03E     NOP
1210  C01C     MOVFF d, fmt
1212  F03F     NOP
1214  0012     RETURN 0
831:                   }
832:           
833:           #ifdef _VFPF_L
834:                   /* Long decimal integer */
835:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
836:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
837:           
838:                       *fmt += CSTRLEN("ld");
839:                       ll = (long long)va_arg(ap, long);
840:                                   
841:                       return dtoa(fp, ll);
842:                   }
843:           #endif
844:           
845:           #ifdef _VFPF_LL
846:                   /* Long long decimal integer */
847:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
848:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
849:           
850:                       *fmt += CSTRLEN("lld");
851:                       ll = va_arg(ap, long long);
852:                                   
853:                       return dtoa(fp, ll);
854:                   }
855:           #endif
856:           
857:           #ifdef _VFPF_J
858:                   /* intmax_t decimal integer */
859:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
860:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
861:           
862:                       *fmt += CSTRLEN("jd");
863:                       ll = (long long)va_arg(ap, intmax_t);
864:                                   
865:                       return dtoa(fp, ll);
866:                   }
867:           #endif
868:           
869:           #ifdef _VFPF_T
870:                   /* ptrdiff_t decimal integer */
871:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
872:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
873:           
874:                       *fmt += CSTRLEN("td");
875:                       ll = (long long)va_arg(ap, ptrdiff_t);
876:                                   
877:                       return dtoa(fp, ll);
878:                   }
879:           #endif
880:           
881:           #ifdef _VFPF_Z
882:                   /* size_t decimal integer */
883:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
884:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
885:           
886:                       *fmt += CSTRLEN("zd");
887:                       ll = (long long)va_arg(ap, size_t);
888:                                   
889:                       return dtoa(fp, ll);
890:                   }
891:           #endif
892:           #endif
893:           
894:           #ifdef _VFPF_E
895:                   /* 'e' style floating point */
896:                   if (ct[0] == 'e') {
897:           
898:                       c = (*fmt)[0];
899:                       ++*fmt;
900:                       f = (long double)va_arg(ap, double);
901:                                   
902:                       return efgtoa(fp, f, c);
903:                   }
904:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
905:           
906:                       c = (*fmt)[1];
907:                       if (isupper((int)(*fmt)[0])) {
908:                           f = va_arg(ap, long double);
909:                       } else {
910:                           f = (long double)va_arg(ap, double);
911:                       }
912:                       *fmt += CSTRLEN("lf");
913:                                   
914:                       return efgtoa(fp, f, c);
915:                   }
916:           #endif
917:           
918:           #ifdef _VFPF_F
919:                   /* 'f' style floating point */
920:                   if (ct[0] == 'f') {
921:           
922:                       c = (*fmt)[0];
923:                       ++*fmt;
924:                       f = (long double)va_arg(ap, double);
925:                                   
926:                       return efgtoa(fp, f, c);
927:                   }
928:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
929:           
930:                       c = (*fmt)[1];
931:                       if (isupper((int)(*fmt)[0])) {
932:                           f = va_arg(ap, long double);
933:                       } else {
934:                           f = (long double)va_arg(ap, double);
935:                       }
936:                       *fmt += CSTRLEN("lf");
937:                                   
938:                       return efgtoa(fp, f, c);
939:                   }
940:           #endif
941:           
942:           #ifdef _VFPF_G
943:                   /* 'g' style floating point */
944:                   if (ct[0] == 'g') {
945:           
946:                       c = (*fmt)[0];
947:                       ++*fmt;
948:                       f = (long double)va_arg(ap, double);
949:                                   
950:                       return efgtoa(fp, f, c);
951:                   }
952:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
953:           
954:                       c = (*fmt)[1];
955:                       if (isupper((int)(*fmt)[0])) {
956:                           f = va_arg(ap, long double);
957:                       } else {
958:                           f = (long double)va_arg(ap, double);
959:                       }
960:                       *fmt += CSTRLEN("lg");
961:                                   
962:                       return efgtoa(fp, f, c);
963:                   }
964:           #endif
965:           
966:           #ifdef _VFPF_O
967:           #ifdef _VFPF_HH
968:                   /* Character octal integer */
969:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
970:           
971:                       *fmt += CSTRLEN("hho");
972:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
973:                                   
974:                       return otoa(fp, llu);
975:                   }
976:           #endif
977:           
978:           #ifdef _VFPF_H
979:                   /* Short octal integer */
980:                   if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
981:           
982:                       *fmt += CSTRLEN("ho");
983:                       llu = (unsigned long long)(unsigned short)va_arg(ap, int);
984:                                   
985:                       return otoa(fp, llu);
986:                   }
987:           #endif
988:           
989:                   /* Octal integer */
990:                   if (*fmt[0] == 'o') {
991:           
992:                       ++*fmt;
993:                       llu = (unsigned long long)va_arg(ap, unsigned int);
994:                                   
995:                       return otoa(fp, llu);
996:                   }
997:           
998:           #ifdef _VFPF_L
999:                   /* Long octal integer */
1000:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1001:          
1002:                      *fmt += CSTRLEN("lo");
1003:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1004:                                  
1005:                      return otoa(fp, llu);
1006:                  }
1007:          #endif
1008:          
1009:          #ifdef _VFPF_LL
1010:                  /* Long long octal integer */
1011:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1012:          
1013:                      *fmt += CSTRLEN("llo");
1014:                      llu = va_arg(ap, unsigned long long);
1015:                                  
1016:                      return otoa(fp, llu);
1017:                  }
1018:          #endif
1019:          
1020:          #ifdef _VFPF_J
1021:                  /* uintmax_t octal integer */
1022:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1023:          
1024:                      *fmt += CSTRLEN("jo");
1025:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_T
1032:                  /* ptrdiff_t octal integer */
1033:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1034:          
1035:                      *fmt += CSTRLEN("to");
1036:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_Z
1043:                  /* size_t octal integer */
1044:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
1045:          
1046:                      *fmt += CSTRLEN("zo");
1047:                      llu = (unsigned long long)va_arg(ap, size_t);
1048:                                  
1049:                      return otoa(fp, llu);
1050:                  }
1051:          #endif
1052:          #endif
1053:          
1054:                  /* Character count */
1055:          #ifdef _VFPF_N
1056:          
1057:          #ifdef _VFPF_HH
1058:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
1059:          
1060:                      *fmt += CSTRLEN("hhn");
1061:                      vp = (void *)va_arg(ap, char *);
1062:                      *(char *)vp = (char)nout;
1063:                      return 0;
1064:                  }
1065:          #endif
1066:          
1067:          #ifdef _VFPF_H
1068:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
1069:          
1070:                      *fmt += CSTRLEN("hn");
1071:                      vp = (void *)va_arg(ap, short *);
1072:                      *(short *)vp = (short)nout;
1073:                      return 0;
1074:                  }
1075:          #endif
1076:          
1077:                  if (*fmt[0] == 'n') {
1078:                      ++*fmt;
1079:                      vp = (void *)va_arg(ap, int *);
1080:                      *(int *)vp = nout;
1081:                      return 0;
1082:                  }
1083:          
1084:          #ifdef _VFPF_L
1085:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1086:          
1087:                      *fmt += CSTRLEN("ln");
1088:                      vp = (void *)va_arg(ap, long *);
1089:                      *(long *)vp = (long)nout;
1090:                      return 0;
1091:                  }
1092:          #endif
1093:          
1094:          #ifdef _VFPF_LL
1095:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1096:          
1097:                      *fmt += CSTRLEN("lln");
1098:                      vp = (void *)va_arg(ap, long long *);
1099:                      *(long long *)vp = (long long)nout;
1100:                      return 0;
1101:                  }
1102:          #endif
1103:          
1104:          #ifdef _VFPF_J
1105:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1106:          
1107:                      *fmt += CSTRLEN("jn");
1108:                      vp = (void *)va_arg(ap, uintmax_t *);
1109:                      *(uintmax_t *)vp = (uintmax_t)nout;
1110:                      return 0;
1111:                  }
1112:          #endif
1113:          
1114:          #ifdef _VFPF_T
1115:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1116:          
1117:                      *fmt += CSTRLEN("tn");
1118:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1119:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1120:                      return 0;
1121:                  }
1122:          #endif
1123:          
1124:          #ifdef _VFPF_Z
1125:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
1126:          
1127:                      *fmt += CSTRLEN("zn");
1128:                      vp = (void *)va_arg(ap, size_t *);
1129:                      *(size_t *)vp = (size_t)nout;
1130:                      return 0;
1131:                  }
1132:          #endif
1133:          
1134:          #endif
1135:          
1136:          #ifdef _VFPF_P
1137:                  /* Pointer */
1138:                  if (*fmt[0] == 'p') {
1139:          
1140:                      ++*fmt;
1141:                      llu = (unsigned long long)(size_t)va_arg(ap, void *);
1142:                                  
1143:                      return xtoa(fp, llu, 'x');
1144:                  }
1145:          #endif
1146:          
1147:          #ifdef _VFPF_S
1148:                  /* String */
1149:                  if (*fmt[0] == 's') {
1150:          
1151:                      ++*fmt;
1152:                      cp = va_arg(ap, char *);
1153:          
1154:                      return stoa(fp, cp);
1155:                  }
1156:          #endif
1157:          
1158:          #ifdef _VFPF_U
1159:          #ifdef _VFPF_HH
1160:                  /* Unsigned character decimal integer */
1161:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
1162:          
1163:                      *fmt += CSTRLEN("hhu");
1164:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1165:                                  
1166:                      return utoa(fp, llu);
1167:                  }
1168:          #endif
1169:          
1170:          #ifdef _VFPF_H
1171:                  /* Unsigned short decimal integer */
1172:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
1173:          
1174:                      *fmt += CSTRLEN("hu");
1175:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1176:                                  
1177:                      return utoa(fp, llu);
1178:                  }
1179:          #endif
1180:          
1181:                  /* Unsigned decimal integer */
1182:                  if (*fmt[0] == 'u') {
1183:          
1184:                      ++*fmt;
1185:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1186:                                  
1187:                      return utoa(fp, llu);
1188:                  }
1189:          
1190:          #ifdef _VFPF_L
1191:                  /* Unsigned long decimal integer */
1192:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
1193:          
1194:                      *fmt += CSTRLEN("lu");
1195:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1196:                                  
1197:                      return utoa(fp, llu);
1198:                  }
1199:          #endif
1200:          
1201:          #ifdef _VFPF_LL
1202:                  /* Unsigned long long decimal integer */
1203:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1204:          
1205:                      *fmt += CSTRLEN("llu");
1206:                      llu = va_arg(ap, unsigned long long);
1207:                                  
1208:                      return utoa(fp, llu);
1209:                  }
1210:          #endif
1211:          
1212:          #ifdef _VFPF_J
1213:                  /* uintmax_t decimal integer */
1214:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1215:          
1216:                      *fmt += CSTRLEN("ju");
1217:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_T
1224:                  /* ptrdiff_t decimal integer */
1225:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1226:          
1227:                      *fmt += CSTRLEN("tu");
1228:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_Z
1235:                  /* size_t decimal integer */
1236:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
1237:          
1238:                      *fmt += CSTRLEN("zu");
1239:                      llu = (unsigned long long)va_arg(ap, size_t);
1240:                                  
1241:                      return utoa(fp, llu);
1242:                  }
1243:          #endif
1244:          #endif
1245:          
1246:          #ifdef _VFPF_X
1247:          #ifdef _VFPF_HH
1248:                  /* Character hexadecimal integer */
1249:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
1250:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1251:          
1252:                      c = (*fmt)[2];
1253:                      *fmt += CSTRLEN("hhx");
1254:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1255:                                  
1256:                      return xtoa(fp, llu, c);
1257:                  }
1258:          #endif
1259:          
1260:          #ifdef _VFPF_H
1261:                  /* Short hexadecimal integer */
1262:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
1263:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1264:          
1265:                      c = (*fmt)[1];
1266:                      *fmt += CSTRLEN("hx");
1267:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1268:                                  
1269:                      return xtoa(fp, llu, c);
1270:                  }
1271:          #endif
1272:          
1273:                  /* Hexadecimal integer */
1274:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
1275:          
1276:                      c = (*fmt)[0];
1277:                      ++*fmt;
1278:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1279:                                  
1280:                      return xtoa(fp, llu, c);
1281:                  }
1282:          
1283:          #ifdef _VFPF_L
1284:                  /* Long hexadecimal integer */
1285:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
1286:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1287:          
1288:                      c = (*fmt)[1];
1289:                      *fmt += CSTRLEN("lx");
1290:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1291:                                  
1292:                      return xtoa(fp, llu, c);
1293:                  }
1294:          #endif
1295:          
1296:          #ifdef _VFPF_LL
1297:                  /* Long long hexadecimal integer */
1298:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1299:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1300:          
1301:                      c = (*fmt)[2];
1302:                      *fmt += CSTRLEN("llx");
1303:                      llu = va_arg(ap, unsigned long long);
1304:                                  
1305:                      return xtoa(fp, llu, c);
1306:                  }
1307:          #endif
1308:          
1309:          #ifdef _VFPF_J
1310:                  /* uintmax_t hexadecimal integer */
1311:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1312:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1313:          
1314:                      c = (*fmt)[1];
1315:                      *fmt += CSTRLEN("jx");
1316:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1317:                                  
1318:                      return xtoa(fp, llu, c);
1319:                  }
1320:          #endif
1321:          
1322:          #ifdef _VFPF_T
1323:                  /* ptrdiff_t hexadecimal integer */
1324:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1325:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1326:          
1327:                      c = (*fmt)[1];
1328:                      *fmt += CSTRLEN("tx");
1329:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1330:                                  
1331:                      return xtoa(fp, llu, c);
1332:                  }
1333:          #endif
1334:          
1335:          #ifdef _VFPF_Z
1336:                  /* size_t hexadecimal integer */
1337:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
1338:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1339:          
1340:                      c = (*fmt)[1];
1341:                      *fmt += CSTRLEN("zx");
1342:                      llu = (unsigned long long)va_arg(ap, size_t);
1343:                                  
1344:                      return xtoa(fp, llu, c);
1345:                  }
1346:          #endif
1347:          #endif
1348:          
1349:                  /* 'Escaped' '%' character */
1350:                  if ((*fmt)[0] == '%') {
1216  503F     MOVF fmt, W, ACCESS
1218  6ED9     MOVWF FSR2, ACCESS
121A  6ADA     CLRF FSR2H, ACCESS
121C  CFDF     MOVFF INDF2, TBLPTR
121E  FFF6     NOP
1220  0E10     MOVLW 0x10
1222  6EF7     MOVWF TBLPTRH, ACCESS
1224  0008     TBLRD*
1226  50F5     MOVF TABLAT, W, ACCESS
1228  0A25     XORLW 0x25
122A  A4D8     BTFSS STATUS, 2, ACCESS
122C  D011     BRA 0x1250
1351:                      ++*fmt;
122E  503F     MOVF fmt, W, ACCESS
1230  6ED9     MOVWF FSR2, ACCESS
1232  6ADA     CLRF FSR2H, ACCESS
1234  2ADF     INCF INDF2, F, ACCESS
1352:                      fputc((int)'%', fp);
1236  0E00     MOVLW 0x0
1238  6E02     MOVWF textData, ACCESS
123A  0E25     MOVLW 0x25
123C  6E01     MOVWF __pcstackCOMRAM, ACCESS
123E  C03E     MOVFF fp, fp
1240  F003     NOP
1242  ECE7     CALL 0x19CE, 0
1244  F00C     NOP
1353:                      return 1;
1246  0E00     MOVLW 0x0
1248  6E3F     MOVWF fmt, ACCESS
124A  0E01     MOVLW 0x1
124C  6E3E     MOVWF fp, ACCESS
124E  0012     RETURN 0
1354:                  }
1355:          
1356:                  /* Unrecognized conversion */
1357:                  ++*fmt;
1250  503F     MOVF fmt, W, ACCESS
1252  6ED9     MOVWF FSR2, ACCESS
1254  6ADA     CLRF FSR2H, ACCESS
1256  2ADF     INCF INDF2, F, ACCESS
1358:                  return 0;
1258  0E00     MOVLW 0x0
125A  6E3F     MOVWF fmt, ACCESS
125C  0E00     MOVLW 0x0
125E  6E3E     MOVWF fp, ACCESS
1260  0012     RETURN 0
1359:              }
1360:          
1361:              /* No conversion, just intervening text */
1362:              fputc((int)(*fmt)[0], fp);
1262  503F     MOVF fmt, W, ACCESS
1264  6ED9     MOVWF FSR2, ACCESS
1266  6ADA     CLRF FSR2H, ACCESS
1268  CFDF     MOVFF INDF2, TBLPTR
126A  FFF6     NOP
126C  0E10     MOVLW 0x10
126E  6EF7     MOVWF TBLPTRH, ACCESS
1270  0008     TBLRD*
1272  50F5     MOVF TABLAT, W, ACCESS
1274  6E01     MOVWF __pcstackCOMRAM, ACCESS
1276  6A02     CLRF textData, ACCESS
1278  C03E     MOVFF fp, fp
127A  F003     NOP
127C  ECE7     CALL 0x19CE, 0
127E  F00C     NOP
1363:              ++*fmt;
1280  503F     MOVF fmt, W, ACCESS
1282  6ED9     MOVWF FSR2, ACCESS
1284  6ADA     CLRF FSR2H, ACCESS
1286  2ADF     INCF INDF2, F, ACCESS
1288  D7DE     BRA 0x1246
1364:              return 1;
1365:          }
1366:          #endif
1367:          
1368:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
1369:          {
1370:          #ifdef _VFPF_CONVERT
1371:              char *cfmt;
1372:          
1373:              cfmt = (char *)fmt;
1B4A  C052     MOVFF fmt, cfmt
1B4C  F054     NOP
1374:              nout = 0;
1B4E  0E00     MOVLW 0x0
1B50  6F61     MOVWF 0x61, BANKED
1B52  0E00     MOVLW 0x0
1B54  6F60     MOVWF nout, BANKED
1375:              while (*cfmt) {
1B56  D00D     BRA 0x1B72
1B72  C054     MOVFF cfmt, TBLPTR
1B74  FFF6     NOP
1B76  0E10     MOVLW 0x10
1B78  6EF7     MOVWF TBLPTRH, ACCESS
1B7A  0008     TBLRD*
1B7C  50F5     MOVF TABLAT, W, ACCESS
1B7E  0900     IORLW 0x0
1B80  A4D8     BTFSS STATUS, 2, ACCESS
1B82  D7EA     BRA 0x1B58
1376:                  nout += vfpfcnvrt(fp, &cfmt, ap);
1B58  C051     MOVFF fp, fp
1B5A  F03E     NOP
1B5C  0E54     MOVLW 0x54
1B5E  6E3F     MOVWF fmt, ACCESS
1B60  C053     MOVFF ap, ap
1B62  F040     NOP
1B64  EC14     CALL 0x1028, 0
1B66  F008     NOP
1B68  503E     MOVF fp, W, ACCESS
1B6A  0100     MOVLB 0x0
1B6C  2760     ADDWF nout, F, BANKED
1B6E  503F     MOVF fmt, W, ACCESS
1B70  2361     ADDWFC 0x61, F, BANKED
1377:              }
1378:              return nout;
1B84  C060     MOVFF nout, fp
1B86  F051     NOP
1B88  C061     MOVFF 0x61, fmt
1B8A  F052     NOP
1379:          #else
1380:              return fputs(fmt, fp);
1381:          #endif
1382:          }
1B8C  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/atoi.c  --------------------------
1:             #include <stdlib.h>
2:             #include <ctype.h>
3:             
4:             int atoi(const char *s)
5:             {
6:             	int n=0, neg=0;
1602  0E00     MOVLW 0x0
1604  6E16     MOVWF 0x16, ACCESS
1606  0E00     MOVLW 0x0
1608  6E15     MOVWF n, ACCESS
160A  0E00     MOVLW 0x0
160C  6E0F     MOVWF buf, ACCESS
160E  0E00     MOVLW 0x0
1610  6E0E     MOVWF neg, ACCESS
7:             	while (isspace(*s)) s++;
1612  D001     BRA 0x1616
1614  2A08     INCF s, F, ACCESS
1616  0E01     MOVLW 0x1
1618  6E14     MOVWF 0x14, ACCESS
161A  C008     MOVFF s, TBLPTR
161C  FFF6     NOP
161E  0E10     MOVLW 0x10
1620  6EF7     MOVWF TBLPTRH, ACCESS
1622  0008     TBLRD*
1624  50F5     MOVF TABLAT, W, ACCESS
1626  0A20     XORLW 0x20
1628  B4D8     BTFSC STATUS, 2, ACCESS
162A  D018     BRA 0x165C
162C  0EF7     MOVLW 0xF7
162E  6E0A     MOVWF fp, ACCESS
1630  0EFF     MOVLW 0xFF
1632  6E0B     MOVWF c, ACCESS
1634  C008     MOVFF s, TBLPTR
1636  FFF6     NOP
1638  0E10     MOVLW 0x10
163A  6EF7     MOVWF TBLPTRH, ACCESS
163C  0008     TBLRD*
163E  50F5     MOVF TABLAT, W, ACCESS
1640  6E0C     MOVWF i, ACCESS
1642  6A0D     CLRF 0xD, ACCESS
1644  500A     MOVF fp, W, ACCESS
1646  260C     ADDWF i, F, ACCESS
1648  500B     MOVF c, W, ACCESS
164A  220D     ADDWFC 0xD, F, ACCESS
164C  500D     MOVF 0xD, W, ACCESS
164E  E104     BNZ 0x1658
1650  0E05     MOVLW 0x5
1652  5C0C     SUBWF i, W, ACCESS
1654  A0D8     BTFSS STATUS, 0, ACCESS
1656  D002     BRA 0x165C
1658  0E00     MOVLW 0x0
165A  6E14     MOVWF 0x14, ACCESS
165C  C014     MOVFF 0x14, p
165E  F010     NOP
1660  6A11     CLRF counter, ACCESS
1662  5010     MOVF p, W, ACCESS
1664  1011     IORWF counter, W, ACCESS
1666  B4D8     BTFSC STATUS, 2, ACCESS
1668  D007     BRA 0x1678
166A  D7D4     BRA 0x1614
8:             	switch (*s) {
9:             	case '-': neg=1;
166C  0E00     MOVLW 0x0
166E  6E0F     MOVWF buf, ACCESS
1670  0E01     MOVLW 0x1
1672  6E0E     MOVWF neg, ACCESS
10:            	case '+': s++;
1674  2A08     INCF s, F, ACCESS
11:            	}
1676  D02E     BRA 0x16D4
1678  C008     MOVFF s, TBLPTR
167A  FFF6     NOP
167C  0E10     MOVLW 0x10
167E  6EF7     MOVWF TBLPTRH, ACCESS
1680  0008     TBLRD*
1682  50F5     MOVF TABLAT, W, ACCESS
1684  6E0A     MOVWF fp, ACCESS
1686  6A0B     CLRF c, ACCESS
1688  500B     MOVF c, W, ACCESS
168A  0A00     XORLW 0x0
168C  A4D8     BTFSS STATUS, 2, ACCESS
168E  D022     BRA 0x16D4
1690  500A     MOVF fp, W, ACCESS
1692  0A2B     XORLW 0x2B
1694  B4D8     BTFSC STATUS, 2, ACCESS
1696  D7EE     BRA 0x1674
1698  0A06     XORLW 0x6
169A  B4D8     BTFSC STATUS, 2, ACCESS
169C  D7E7     BRA 0x166C
169E  D01A     BRA 0x16D4
12:            	/* Compute n as a negative number to avoid overflow on INT_MIN */
13:            	while (isdigit(*s))
16D4  0ED0     MOVLW 0xD0
16D6  6E0A     MOVWF fp, ACCESS
16D8  0EFF     MOVLW 0xFF
16DA  6E0B     MOVWF c, ACCESS
16DC  C008     MOVFF s, TBLPTR
16DE  FFF6     NOP
16E0  0E10     MOVLW 0x10
16E2  6EF7     MOVWF TBLPTRH, ACCESS
16E4  0008     TBLRD*
16E6  50F5     MOVF TABLAT, W, ACCESS
16E8  6E0C     MOVWF i, ACCESS
16EA  6A0D     CLRF 0xD, ACCESS
16EC  500A     MOVF fp, W, ACCESS
16EE  260C     ADDWF i, F, ACCESS
16F0  500B     MOVF c, W, ACCESS
16F2  220D     ADDWFC 0xD, F, ACCESS
16F4  500D     MOVF 0xD, W, ACCESS
16F6  E106     BNZ 0x1704
16F8  0E0A     MOVLW 0xA
16FA  5C0C     SUBWF i, W, ACCESS
16FC  B0D8     BTFSC STATUS, 0, ACCESS
16FE  D002     BRA 0x1704
1700  0E01     MOVLW 0x1
1702  D001     BRA 0x1706
1704  0E00     MOVLW 0x0
1706  6E12     MOVWF sign, ACCESS
1708  6A13     CLRF quotient, ACCESS
170A  5012     MOVF sign, W, ACCESS
170C  1013     IORWF quotient, W, ACCESS
170E  A4D8     BTFSS STATUS, 2, ACCESS
1710  D7C7     BRA 0x16A0
14:            		n = 10*n - (*s++ - '0');
16A0  C015     MOVFF n, __pcstackCOMRAM
16A2  F001     NOP
16A4  C016     MOVFF 0x16, textData
16A6  F002     NOP
16A8  0E00     MOVLW 0x0
16AA  6E04     MOVWF 0x4, ACCESS
16AC  0E0A     MOVLW 0xA
16AE  6E03     MOVWF fp, ACCESS
16B0  EC81     CALL 0x1D02, 0
16B2  F00E     NOP
16B4  C008     MOVFF s, TBLPTR
16B6  FFF6     NOP
16B8  0E10     MOVLW 0x10
16BA  6EF7     MOVWF TBLPTRH, ACCESS
16BC  0008     TBLRD*
16BE  50F5     MOVF TABLAT, W, ACCESS
16C0  5E01     SUBWF __pcstackCOMRAM, F, ACCESS
16C2  0E00     MOVLW 0x0
16C4  5A02     SUBWFB textData, F, ACCESS
16C6  0E30     MOVLW 0x30
16C8  2401     ADDWF __pcstackCOMRAM, W, ACCESS
16CA  6E15     MOVWF n, ACCESS
16CC  0E00     MOVLW 0x0
16CE  2002     ADDWFC textData, W, ACCESS
16D0  6E16     MOVWF 0x16, ACCESS
16D2  D7D0     BRA 0x1674
15:            	return neg ? n : -n;
1712  500E     MOVF neg, W, ACCESS
1714  100F     IORWF buf, W, ACCESS
1716  A4D8     BTFSS STATUS, 2, ACCESS
1718  D00D     BRA 0x1734
171A  C015     MOVFF n, fp
171C  F00A     NOP
171E  C016     MOVFF 0x16, c
1720  F00B     NOP
1722  1E0A     COMF fp, F, ACCESS
1724  1E0B     COMF c, F, ACCESS
1726  4A0A     INFSNZ fp, F, ACCESS
1728  2A0B     INCF c, F, ACCESS
172A  C00A     MOVFF fp, s
172C  F008     NOP
172E  C00B     MOVFF c, divisor
1730  F009     NOP
1732  0012     RETURN 0
1734  C015     MOVFF n, s
1736  F008     NOP
1738  C016     MOVFF 0x16, divisor
173A  F009     NOP
16:            }
173C  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/aomod.c  -------------------------
1:             // long long signed unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aomod(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aomod(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
173E  0E00     MOVLW 0x0
1740  6E12     MOVWF sign, ACCESS
15:            	if(dividend < 0) {
1742  AE08     BTFSS s, 7, ACCESS
1744  D012     BRA 0x176A
16:            		dividend = -dividend;
1746  1E08     COMF s, F, ACCESS
1748  1E07     COMF i, F, ACCESS
174A  1E06     COMF lineNum, F, ACCESS
174C  1E05     COMF product, F, ACCESS
174E  1E04     COMF 0x4, F, ACCESS
1750  1E03     COMF fp, F, ACCESS
1752  1E02     COMF textData, F, ACCESS
1754  6C01     NEGF __pcstackCOMRAM, ACCESS
1756  0E00     MOVLW 0x0
1758  2202     ADDWFC textData, F, ACCESS
175A  2203     ADDWFC fp, F, ACCESS
175C  2204     ADDWFC 0x4, F, ACCESS
175E  2205     ADDWFC product, F, ACCESS
1760  2206     ADDWFC lineNum, F, ACCESS
1762  2207     ADDWFC i, F, ACCESS
1764  2208     ADDWFC s, F, ACCESS
17:            		sign = 1;
1766  0E01     MOVLW 0x1
1768  6E12     MOVWF sign, ACCESS
18:            	}
19:            	if(divisor < 0)
176A  AE10     BTFSS p, 7, ACCESS
176C  D010     BRA 0x178E
20:            		divisor = -divisor;
176E  1E10     COMF p, F, ACCESS
1770  1E0F     COMF buf, F, ACCESS
1772  1E0E     COMF neg, F, ACCESS
1774  1E0D     COMF 0xD, F, ACCESS
1776  1E0C     COMF i, F, ACCESS
1778  1E0B     COMF c, F, ACCESS
177A  1E0A     COMF fp, F, ACCESS
177C  6C09     NEGF divisor, ACCESS
177E  0E00     MOVLW 0x0
1780  220A     ADDWFC fp, F, ACCESS
1782  220B     ADDWFC c, F, ACCESS
1784  220C     ADDWFC i, F, ACCESS
1786  220D     ADDWFC 0xD, F, ACCESS
1788  220E     ADDWFC neg, F, ACCESS
178A  220F     ADDWFC buf, F, ACCESS
178C  2210     ADDWFC p, F, ACCESS
21:            	if(divisor != 0) {
178E  5009     MOVF divisor, W, ACCESS
1790  100A     IORWF fp, W, ACCESS
1792  100B     IORWF c, W, ACCESS
1794  100C     IORWF i, W, ACCESS
1796  100D     IORWF 0xD, W, ACCESS
1798  100E     IORWF neg, W, ACCESS
179A  100F     IORWF buf, W, ACCESS
179C  1010     IORWF p, W, ACCESS
179E  B4D8     BTFSC STATUS, 2, ACCESS
17A0  D03C     BRA 0x181A
22:            		counter = 1;
17A2  0E01     MOVLW 0x1
17A4  6E11     MOVWF counter, ACCESS
23:            		while((divisor & 0x8000000000000000ULL) == 0) {
17A6  D00A     BRA 0x17BC
17BC  AE10     BTFSS p, 7, ACCESS
17BE  D7F4     BRA 0x17A8
24:            			divisor <<= 1;
17A8  90D8     BCF STATUS, 0, ACCESS
17AA  3609     RLCF divisor, F, ACCESS
17AC  360A     RLCF fp, F, ACCESS
17AE  360B     RLCF c, F, ACCESS
17B0  360C     RLCF i, F, ACCESS
17B2  360D     RLCF 0xD, F, ACCESS
17B4  360E     RLCF neg, F, ACCESS
17B6  360F     RLCF buf, F, ACCESS
17B8  3610     RLCF p, F, ACCESS
25:            			counter++;
17BA  2A11     INCF counter, F, ACCESS
26:            		}
27:            		do {
28:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
17C0  5009     MOVF divisor, W, ACCESS
17C2  5C01     SUBWF __pcstackCOMRAM, W, ACCESS
17C4  500A     MOVF fp, W, ACCESS
17C6  5802     SUBWFB textData, W, ACCESS
17C8  500B     MOVF c, W, ACCESS
17CA  5803     SUBWFB fp, W, ACCESS
17CC  500C     MOVF i, W, ACCESS
17CE  5804     SUBWFB 0x4, W, ACCESS
17D0  500D     MOVF 0xD, W, ACCESS
17D2  5805     SUBWFB product, W, ACCESS
17D4  500E     MOVF neg, W, ACCESS
17D6  5806     SUBWFB lineNum, W, ACCESS
17D8  500F     MOVF buf, W, ACCESS
17DA  5807     SUBWFB i, W, ACCESS
17DC  5010     MOVF p, W, ACCESS
17DE  5808     SUBWFB s, W, ACCESS
17E0  A0D8     BTFSS STATUS, 0, ACCESS
17E2  D010     BRA 0x1804
29:            				dividend -= divisor;
17E4  5009     MOVF divisor, W, ACCESS
17E6  5E01     SUBWF __pcstackCOMRAM, F, ACCESS
17E8  500A     MOVF fp, W, ACCESS
17EA  5A02     SUBWFB textData, F, ACCESS
17EC  500B     MOVF c, W, ACCESS
17EE  5A03     SUBWFB fp, F, ACCESS
17F0  500C     MOVF i, W, ACCESS
17F2  5A04     SUBWFB 0x4, F, ACCESS
17F4  500D     MOVF 0xD, W, ACCESS
17F6  5A05     SUBWFB product, F, ACCESS
17F8  500E     MOVF neg, W, ACCESS
17FA  5A06     SUBWFB lineNum, F, ACCESS
17FC  500F     MOVF buf, W, ACCESS
17FE  5A07     SUBWFB i, F, ACCESS
1800  5010     MOVF p, W, ACCESS
1802  5A08     SUBWFB s, F, ACCESS
30:            			*(unsigned long long int *)&divisor >>= 1;
1804  90D8     BCF STATUS, 0, ACCESS
1806  3210     RRCF p, F, ACCESS
1808  320F     RRCF buf, F, ACCESS
180A  320E     RRCF neg, F, ACCESS
180C  320D     RRCF 0xD, F, ACCESS
180E  320C     RRCF i, F, ACCESS
1810  320B     RRCF c, F, ACCESS
1812  320A     RRCF fp, F, ACCESS
1814  3209     RRCF divisor, F, ACCESS
31:            		} while(--counter != 0);
1816  2E11     DECFSZ counter, F, ACCESS
1818  D7D3     BRA 0x17C0
32:            	}
33:            	if(sign)
181A  5012     MOVF sign, W, ACCESS
181C  B4D8     BTFSC STATUS, 2, ACCESS
181E  D010     BRA 0x1840
34:            		dividend = -dividend;
1820  1E08     COMF s, F, ACCESS
1822  1E07     COMF i, F, ACCESS
1824  1E06     COMF lineNum, F, ACCESS
1826  1E05     COMF product, F, ACCESS
1828  1E04     COMF 0x4, F, ACCESS
182A  1E03     COMF fp, F, ACCESS
182C  1E02     COMF textData, F, ACCESS
182E  6C01     NEGF __pcstackCOMRAM, ACCESS
1830  0E00     MOVLW 0x0
1832  2202     ADDWFC textData, F, ACCESS
1834  2203     ADDWFC fp, F, ACCESS
1836  2204     ADDWFC 0x4, F, ACCESS
1838  2205     ADDWFC product, F, ACCESS
183A  2206     ADDWFC lineNum, F, ACCESS
183C  2207     ADDWFC i, F, ACCESS
183E  2208     ADDWFC s, F, ACCESS
35:            	return dividend;
1840  C001     MOVFF __pcstackCOMRAM, __pcstackCOMRAM
1842  F001     NOP
1844  C002     MOVFF textData, textData
1846  F002     NOP
1848  C003     MOVFF fp, fp
184A  F003     NOP
184C  C004     MOVFF 0x4, 0x4
184E  F004     NOP
1850  C005     MOVFF product, product
1852  F005     NOP
1854  C006     MOVFF lineNum, lineNum
1856  F006     NOP
1858  C007     MOVFF i, i
185A  F007     NOP
185C  C008     MOVFF s, s
185E  F008     NOP
36:            }
1860  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/aodiv.c  -------------------------
1:             // long long signed unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aodiv(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aodiv(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	signed long long int	quotient;
13:            	unsigned char	counter, sign;
14:            
15:            	sign = 0;
14BA  0E00     MOVLW 0x0
14BC  6E12     MOVWF sign, ACCESS
16:            	if(divisor < 0) {
14BE  AE10     BTFSS p, 7, ACCESS
14C0  D012     BRA 0x14E6
17:            		divisor = -divisor;
14C2  1E10     COMF p, F, ACCESS
14C4  1E0F     COMF buf, F, ACCESS
14C6  1E0E     COMF neg, F, ACCESS
14C8  1E0D     COMF 0xD, F, ACCESS
14CA  1E0C     COMF i, F, ACCESS
14CC  1E0B     COMF c, F, ACCESS
14CE  1E0A     COMF fp, F, ACCESS
14D0  6C09     NEGF divisor, ACCESS
14D2  0E00     MOVLW 0x0
14D4  220A     ADDWFC fp, F, ACCESS
14D6  220B     ADDWFC c, F, ACCESS
14D8  220C     ADDWFC i, F, ACCESS
14DA  220D     ADDWFC 0xD, F, ACCESS
14DC  220E     ADDWFC neg, F, ACCESS
14DE  220F     ADDWFC buf, F, ACCESS
14E0  2210     ADDWFC p, F, ACCESS
18:            		sign = 1;
14E2  0E01     MOVLW 0x1
14E4  6E12     MOVWF sign, ACCESS
19:            	}
20:            	if(dividend < 0) {
14E6  AE08     BTFSS s, 7, ACCESS
14E8  D012     BRA 0x150E
21:            		dividend = -dividend;
14EA  1E08     COMF s, F, ACCESS
14EC  1E07     COMF i, F, ACCESS
14EE  1E06     COMF lineNum, F, ACCESS
14F0  1E05     COMF product, F, ACCESS
14F2  1E04     COMF 0x4, F, ACCESS
14F4  1E03     COMF fp, F, ACCESS
14F6  1E02     COMF textData, F, ACCESS
14F8  6C01     NEGF __pcstackCOMRAM, ACCESS
14FA  0E00     MOVLW 0x0
14FC  2202     ADDWFC textData, F, ACCESS
14FE  2203     ADDWFC fp, F, ACCESS
1500  2204     ADDWFC 0x4, F, ACCESS
1502  2205     ADDWFC product, F, ACCESS
1504  2206     ADDWFC lineNum, F, ACCESS
1506  2207     ADDWFC i, F, ACCESS
1508  2208     ADDWFC s, F, ACCESS
22:            		sign ^= 1;
150A  0E01     MOVLW 0x1
150C  1A12     XORWF sign, F, ACCESS
23:            	}
24:            	quotient = 0;
150E  EE20     LFSR 2, 0x13
1510  F013     NOP
1512  0E07     MOVLW 0x7
1514  6ADE     CLRF POSTINC2, ACCESS
1516  06E8     DECF WREG, F, ACCESS
1518  E2FD     BC 0x1514
25:            	if(divisor != 0) {
151A  5009     MOVF divisor, W, ACCESS
151C  100A     IORWF fp, W, ACCESS
151E  100B     IORWF c, W, ACCESS
1520  100C     IORWF i, W, ACCESS
1522  100D     IORWF 0xD, W, ACCESS
1524  100E     IORWF neg, W, ACCESS
1526  100F     IORWF buf, W, ACCESS
1528  1010     IORWF p, W, ACCESS
152A  B4D8     BTFSC STATUS, 2, ACCESS
152C  D046     BRA 0x15BA
26:            		counter = 1;
152E  0E01     MOVLW 0x1
1530  6E11     MOVWF counter, ACCESS
27:            		while((divisor & 0x8000000000000000ULL) == 0) {
1532  D00A     BRA 0x1548
1548  AE10     BTFSS p, 7, ACCESS
154A  D7F4     BRA 0x1534
28:            			divisor <<= 1;
1534  90D8     BCF STATUS, 0, ACCESS
1536  3609     RLCF divisor, F, ACCESS
1538  360A     RLCF fp, F, ACCESS
153A  360B     RLCF c, F, ACCESS
153C  360C     RLCF i, F, ACCESS
153E  360D     RLCF 0xD, F, ACCESS
1540  360E     RLCF neg, F, ACCESS
1542  360F     RLCF buf, F, ACCESS
1544  3610     RLCF p, F, ACCESS
29:            			counter++;
1546  2A11     INCF counter, F, ACCESS
30:            		}
31:            		do {
32:            			quotient <<= 1;
154C  90D8     BCF STATUS, 0, ACCESS
154E  3613     RLCF quotient, F, ACCESS
1550  3614     RLCF 0x14, F, ACCESS
1552  3615     RLCF n, F, ACCESS
1554  3616     RLCF 0x16, F, ACCESS
1556  3617     RLCF 0x17, F, ACCESS
1558  3618     RLCF 0x18, F, ACCESS
155A  3619     RLCF 0x19, F, ACCESS
155C  361A     RLCF 0x1A, F, ACCESS
33:            			if((unsigned long long)divisor <= (unsigned long long)dividend) {
155E  5009     MOVF divisor, W, ACCESS
1560  5C01     SUBWF __pcstackCOMRAM, W, ACCESS
1562  500A     MOVF fp, W, ACCESS
1564  5802     SUBWFB textData, W, ACCESS
1566  500B     MOVF c, W, ACCESS
1568  5803     SUBWFB fp, W, ACCESS
156A  500C     MOVF i, W, ACCESS
156C  5804     SUBWFB 0x4, W, ACCESS
156E  500D     MOVF 0xD, W, ACCESS
1570  5805     SUBWFB product, W, ACCESS
1572  500E     MOVF neg, W, ACCESS
1574  5806     SUBWFB lineNum, W, ACCESS
1576  500F     MOVF buf, W, ACCESS
1578  5807     SUBWFB i, W, ACCESS
157A  5010     MOVF p, W, ACCESS
157C  5808     SUBWFB s, W, ACCESS
157E  A0D8     BTFSS STATUS, 0, ACCESS
1580  D011     BRA 0x15A4
34:            				dividend -= divisor;
1582  5009     MOVF divisor, W, ACCESS
1584  5E01     SUBWF __pcstackCOMRAM, F, ACCESS
1586  500A     MOVF fp, W, ACCESS
1588  5A02     SUBWFB textData, F, ACCESS
158A  500B     MOVF c, W, ACCESS
158C  5A03     SUBWFB fp, F, ACCESS
158E  500C     MOVF i, W, ACCESS
1590  5A04     SUBWFB 0x4, F, ACCESS
1592  500D     MOVF 0xD, W, ACCESS
1594  5A05     SUBWFB product, F, ACCESS
1596  500E     MOVF neg, W, ACCESS
1598  5A06     SUBWFB lineNum, F, ACCESS
159A  500F     MOVF buf, W, ACCESS
159C  5A07     SUBWFB i, F, ACCESS
159E  5010     MOVF p, W, ACCESS
15A0  5A08     SUBWFB s, F, ACCESS
35:            				quotient |= 1;
15A2  8013     BSF quotient, 0, ACCESS
36:            			}
37:            			*(unsigned long long int *)&divisor >>= 1;
15A4  90D8     BCF STATUS, 0, ACCESS
15A6  3210     RRCF p, F, ACCESS
15A8  320F     RRCF buf, F, ACCESS
15AA  320E     RRCF neg, F, ACCESS
15AC  320D     RRCF 0xD, F, ACCESS
15AE  320C     RRCF i, F, ACCESS
15B0  320B     RRCF c, F, ACCESS
15B2  320A     RRCF fp, F, ACCESS
15B4  3209     RRCF divisor, F, ACCESS
38:            		} while(--counter != 0);
15B6  2E11     DECFSZ counter, F, ACCESS
15B8  D7C9     BRA 0x154C
39:            	}
40:            	if(sign)
15BA  5012     MOVF sign, W, ACCESS
15BC  B4D8     BTFSC STATUS, 2, ACCESS
15BE  D010     BRA 0x15E0
41:            		quotient = -quotient;
15C0  1E1A     COMF 0x1A, F, ACCESS
15C2  1E19     COMF 0x19, F, ACCESS
15C4  1E18     COMF 0x18, F, ACCESS
15C6  1E17     COMF 0x17, F, ACCESS
15C8  1E16     COMF 0x16, F, ACCESS
15CA  1E15     COMF n, F, ACCESS
15CC  1E14     COMF 0x14, F, ACCESS
15CE  6C13     NEGF quotient, ACCESS
15D0  0E00     MOVLW 0x0
15D2  2214     ADDWFC 0x14, F, ACCESS
15D4  2215     ADDWFC n, F, ACCESS
15D6  2216     ADDWFC 0x16, F, ACCESS
15D8  2217     ADDWFC 0x17, F, ACCESS
15DA  2218     ADDWFC 0x18, F, ACCESS
15DC  2219     ADDWFC 0x19, F, ACCESS
15DE  221A     ADDWFC 0x1A, F, ACCESS
42:            	return quotient;
15E0  C013     MOVFF quotient, __pcstackCOMRAM
15E2  F001     NOP
15E4  C014     MOVFF 0x14, textData
15E6  F002     NOP
15E8  C015     MOVFF n, fp
15EA  F003     NOP
15EC  C016     MOVFF 0x16, 0x4
15EE  F004     NOP
15F0  C017     MOVFF 0x17, product
15F2  F005     NOP
15F4  C018     MOVFF 0x18, lineNum
15F6  F006     NOP
15F8  C019     MOVFF 0x19, i
15FA  F007     NOP
15FC  C01A     MOVFF 0x1A, s
15FE  F008     NOP
43:            }
1600  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/abs.c  ---------------------------
1:             int abs(int a)
2:             {
3:             	return a>0 ? a : -a;
1C44  BE14     BTFSC 0x14, 7, ACCESS
1C46  D005     BRA 0x1C52
1C48  5014     MOVF 0x14, W, ACCESS
1C4A  E110     BNZ 0x1C6C
1C4C  0413     DECF quotient, W, ACCESS
1C4E  B0D8     BTFSC STATUS, 0, ACCESS
1C50  D00D     BRA 0x1C6C
1C52  C013     MOVFF quotient, n
1C54  F015     NOP
1C56  C014     MOVFF 0x14, 0x16
1C58  F016     NOP
1C5A  1E15     COMF n, F, ACCESS
1C5C  1E16     COMF 0x16, F, ACCESS
1C5E  4A15     INFSNZ n, F, ACCESS
1C60  2A16     INCF 0x16, F, ACCESS
1C62  C015     MOVFF n, quotient
1C64  F013     NOP
1C66  C016     MOVFF 0x16, 0x14
1C68  F014     NOP
1C6A  0012     RETURN 0
1C6C  C013     MOVFF quotient, quotient
1C6E  F013     NOP
1C70  C014     MOVFF 0x14, 0x14
1C72  F014     NOP
4:             }
1C74  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/Umul16.c  ------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
1D02  5001     MOVF __pcstackCOMRAM, W, ACCESS
1D04  0203     MULWF fp, ACCESS
1D06  CFF3     MOVFF PROD, product
1D08  F005     NOP
1D0A  CFF4     MOVFF PRODH, lineNum
1D0C  F006     NOP
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
1D0E  5001     MOVF __pcstackCOMRAM, W, ACCESS
1D10  0204     MULWF 0x4, ACCESS
1D12  50F3     MOVF PROD, W, ACCESS
1D14  2606     ADDWF lineNum, F, ACCESS
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
1D16  5002     MOVF textData, W, ACCESS
1D18  0203     MULWF fp, ACCESS
1D1A  50F3     MOVF PROD, W, ACCESS
1D1C  2606     ADDWF lineNum, F, ACCESS
40:            
41:            #else
42:            
43:            	product = 0;
44:            	do {
45:            		if(multiplier & 1)
46:            			product += multiplicand;
47:            		multiplicand <<= 1;
48:            		multiplier >>= 1;
49:            	} while(multiplier != 0);
50:            
51:            #endif
52:                    return product;
1D1E  C005     MOVFF product, __pcstackCOMRAM
1D20  F001     NOP
1D22  C006     MOVFF lineNum, textData
1D24  F002     NOP
53:            }
1D26  0012     RETURN 0
